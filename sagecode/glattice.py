# -*- coding: utf-8 -*-
r"""
Classes of G-Lattices
======================

G-Lattices are defined by equipping the standard lattice in `\ZZ^n` with an action of a finite group.

We allow trivial group actions.


All lattices inherit from :class:`Lattice_generic`, and there are currently
two types of lattices: ambient lattices (:class:`Lattice_ambient`) and sublattices of ambient
lattices (:class:`SubLattice`).

To specify a lattice, you need to provide some of the following data:

- ``n`` -- a non-negative integer (optional), giving the rank of the lattice.
    If given, implies the trivial action of ``G``.

- ``G`` -- a group, specified either as a Sage group or as a list of integers
    giving the abelian invariants of a finite abelian group.  If not specified,
    can be implied by ``im_gens`` (the group generated by these matrices) or
    taken as trivial (if ``im_gens`` is not given).

- ``im_gens`` -- a list of matrices of length equal to the number of generators
    of ``G``.  If not given, may be inferred from `G`: if ``G`` is a matrix group
    over the integers, ``im_gens`` will just be the generators of ``G``;
    if ``G`` is a permutation group then the default action is given by permuting
    basis vectors.


GLattice(group, actions)
-------------------------------

You can define a lattice by giving a group and matrix actions for each generator::

    sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
    sage: G.gens()
    [(3,4,5), (1,2)]
    sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
    sage: act2 = matrix(3, [1, 0, 0, 0, 1, 0, 0, 0, 1])
    sage: act = [act1, act2]

We created the group `G` as `C_2 \times C_3`, and the action where `C_2` acts trivially.
One has to be careful when defining the action to match sage's order of the generators::

    sage: L = GLattice(G, act); L
    Ambient lattice of rank 3 with an action by a group of order 6

    sage: L._action_matrices
    [
    [0 1 0]  [1 0 0]
    [0 0 1]  [0 1 0]
    [1 0 0], [0 0 1]
    ]

GLattice(group, n)
-------------------------

If you provide a group and an integer `n`, you get the lattice of rank `n` with
trivial action of the group::

    sage: L = GLattice(SymmetricGroup(3), 2); L
    Ambient lattice of rank 2 with the trivial action of a group of order 6
    sage: L._action_matrices
    [
    [1 0]  [1 0]
    [0 1], [0 1]
    ]

If you do not provide an integer, it will give the natural permutation action of the group as a permutation group::

    sage: L = GLattice([2, 3]); L; L._action_matrices
    Ambient lattice of rank 5 with a faithful action by a group of order 6
    [
    [1 0 0 0 0]  [0 1 0 0 0]
    [0 1 0 0 0]  [1 0 0 0 0]
    [0 0 0 1 0]  [0 0 1 0 0]
    [0 0 0 0 1]  [0 0 0 1 0]
    [0 0 1 0 0], [0 0 0 0 1]
    ]


GLattice(List_of_matrices) or GLattice(Matrix_Group)
------------------------------------------------------------------

If you provide a list of matrices, Sage will construct the lattice with rank
equal to the the size of the matrices, and the group will be understood to be
the subgroup of `GL_n(\ZZ)` generated by the provided matrices.
This subgroup should be finite::

    sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
    sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
    sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
    sage: L = GLattice([m1, m2, m3]); L
    Ambient lattice of rank 3 with a faithful action by a group of order 8

    sage: L._action_matrices
    [
    [-1  0  0]  [ 0  0  1]  [ 0  1  0]
    [ 0 -1  0]  [-1 -1 -1]  [ 1  0  0]
    [ 0  0 -1], [ 1  0  0], [-1 -1 -1]
    ]

::

    sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
    sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
    sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
    sage: G = MatrixGroup([m1, m2, m3]); G
    Matrix group over Integer Ring with 3 generators (
    [ 0  0  1]  [-1  0  0]  [ 0  1  0]
    [-1 -1 -1]  [ 0 -1  0]  [ 1  0  0]
    [ 1  0  0], [ 0  0 -1], [-1 -1 -1]
    )
    sage: L = GLattice(G); L
    Ambient lattice of rank 3 with a faithful action by a group of order 8


GLattice(list_of_integers, action)
------------------------------------

Providing a list of integers corresponding to a finite abelian group, and action
matrices (or integer for the trivial action)::

    sage: L = GLattice([2, 2, 2, 2]); L
    Ambient lattice of rank 8 with a faithful action by a group of order 16
    sage: L._group
    Permutation Group with generators [(7,8), (5,6), (3,4), (1,2)]


SubLattice(lattice, generators)
---------------------------------

In order to create a sublattice, give a lattice and a list of vectors in the lattice::

    sage: L = GLattice(DihedralGroup(6), 3)
    sage: x, y, z = L.basis()
    sage: L.sublattice([x, y + 2*z])
    Sublattice of degree 3 and rank 2 with the trivial action of a group of order 12 and echelon basis matrix
    [1 0 0]
    [0 1 2]

The algorithm checks if the sublattice is stable under the group action::

    sage: L = GLattice(SymmetricGroup(2), [matrix([[0, 1], [1, 0]])])
    sage: L.sublattice([L.basis()[0]])
    Traceback (most recent call last):
    ...
    ValueError: The basis is not stable under the action of the group


Attributes of a lattice
-------------------------

- ``lattice._group`` -- the group acting on the lattice

- ``lattice._generators`` -- the generators of that group

- ``lattice._rank`` -- the rank of the lattice (if rank 0 some of the below
    will be None since GAP does not support GL(0))

- ``lattice._action_matrices`` -- the matrices through which the group acts

- ``lattice._action_morphism`` -- the map (as a group homomorphism in GAP) from
    the group to `GL_n(\ZZ)`

- ``lattice._GAPMap`` -- returns the Sage :class:`sage.categories.map.Map` element
    representing Lattice.action_morphism

- ``lattice._action`` -- the Sage action of the group on the lattice

- ``lattice._ambient_lattice`` -- the parent lattice; this attribute only exists for
    the SubLattice class


Methods of a lattice
----------------------

- :meth:`Lattice_generic.group` -- the group acting on the lattice

- :meth:`Lattice_generic.display_action` -- displays the matrices corresponding to the group action

- :meth:`Lattice_generic.subgroup_lattice` -- restricts the action of the group to a subgroup.

- :meth:`Lattice_generic.direct_sum` -- takes the direct sum of two lattices.

- :meth:`Lattice_generic.dim_shift` -- returns a lattice with shifted cohomological groups

- :meth:`Lattice_generic.ambient_lattice` -- returns the parent ambient lattice.

- :meth:`Lattice_generic.pullback_lattice` -- returns a lattice with the pullback action of a group with map to the current lattice group.

- :meth:`Lattice_generic.fixed_sublattice` -- the sublattice of elements fixed by the group.

- :meth:`Lattice_generic.quotient_lattice` -- the quotient lattice of a lattice by some sublattice

- :meth:`Lattice_generic.isomorphic_ambient_lattice` -- gives an isomorphic ambient lattice, returns the same lattice if it is already ambient.

- :meth:`Lattice_generic.GAPMatrixGroup` -- the matrix group corresponding to the action, as a GAP group.

- :meth:`Lattice_generic.colattice` -- the lattice where the action of the group is composed with the inverse transpose automorphism.

- :meth:`Lattice_generic.tate_cohomology` -- computes the Tate cohomology of the lattice

- :meth:`Lattice_generic.induced_lattice` -- the induction of the lattice to a bigger group

- :meth:`Lattice_generic.zero_sum_sublattice` -- the sublattice of zero sum vectors, can also give an ambient lattice isomorphic to this zero sum sublattice.

- :meth:`Lattice_generic.first_coboundary_space` -- the space of 1-coboundaries.

- :meth:`Lattice_generic.first_cocycle_space` -- the space of 1-cocycles.

- :meth:`Lattice_generic.first_cohomology_group` -- the first cohomology group.

- :meth:`Lattice_generic.Tate_Shafarevich_lattice` -- the tate-shafarevich group, i.e. the kernel of restriction maps to a list of subgroups.

- :meth:`Lattice_generic.diagonal_embedding` -- diagonal embedding of the lattice into the direct sum with itself.

- :meth:`Lattice_generic.surjection_from_square` -- surjection from the direct sum with itself given by the sum of elements.

- :meth:`Lattice_generic.stabilizer` -- compute the stabilizer subgroup of a sublattice.

- :meth:`Lattice_generic.orbit` -- compute the orbit of an element.

- :meth:`Lattice_generic.orbit_permutation_cover` -- surjection from the lattice freely generated by the orbit to the orbit.

- :meth:`Lattice_generic.permutation_cover` -- surjection of permutation lattice onto the lattice.

- :meth:`Lattice_generic.left_morphism` -- lattice morphism acting on the left.

- :meth:`Lattice_generic.action_is_trivial` -- determine if the action is trivial.

- :meth:`Lattice_generic.action_is_faithful` -- determine if the action is faithful.

- :meth:`Lattice_generic.action_kernel` -- determine the maximal subgroup acting trivially  on the lattice.

- :meth:`Lattice_generic.complete_submodule` -- complete a submodule into a sublattice.

- :meth:`Lattice_generic.norm` -- norm map.

- :meth:`Lattice_generic.identity_morphism` -- identity endomorphism.

- :meth:`Lattice_generic.coflabby_resolution` -- determine a coflabby resolution of the lattice.

- :meth:`Lattice_generic.flabby_resolution` -- determine a flabby resolution of the lattice.

- :meth:`Lattice_generic.is_coflabby` -- determine if a lattice is coflabby.

- :meth:`Lattice_generic.is_flabby` -- determine if a lattice is flabby.

- :meth:`Lattice_generic.dual` -- return the dual of a lattice.

- :meth:`SubLattice.injection_morphism` -- injection of a sublattice into its parent ambient lattice.

- :meth:`SubLattice.ambient_lattice` -- parent ambient lattice containing the sublattice.


EXAMPLES::

    sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
    sage: G.gens()
    [(3,4,5), (1,2)]
    sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
    sage: act2 = matrix(3, [1, 0, 0, 0, 1, 0, 0, 0, 1])
    sage: act = [act1,act2]
    sage: L1 = GLattice(G, act); L1
    Ambient lattice of rank 3 with an action by a group of order 6

``L1`` is the group `C_2 \times C_3` acting on `\ZZ^3` via the identity for the first component and
an order 3 permutation for the second component.

::

    sage: L2 = GLattice(SymmetricGroup(3), 4); L2
    Ambient lattice of rank 4 with the trivial action of a group of order 6

``L2`` is the symmetric group `S_3` acting trivially on `\ZZ^4`.

::

    sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
    sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
    sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
    sage: L3 = GLattice([m1, m2, m3]); L3
    Ambient lattice of rank 3 with a faithful action by a group of order 8

``L3`` is the lattice with action of the group generated by the matrices ``m1``, ``m2``, ``m3``,
which is also the group of GAP ID (3,3,3,3) (using the labeling of the function ``MatGroupZClass``
from [HY2017]_).
"""

###########################################################################
#       Copyright (C) 2018-2019
#     Thomas Rüd <tompa.rud@gmail.com>
#     David Roe <roed.math@gmail.com>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
###########################################################################


from __future__ import print_function, absolute_import

from sage.categories.action import PrecomposedAction, TrivialAction
from sage.rings.integer_ring import ZZ
from sage.rings.integer import Integer
from sage.groups.perm_gps.permgroup import PermutationGroup
from sage.groups.perm_gps.permgroup_named import SymmetricGroup
from sage.categories.map import Map
from sage.modules.free_module import FreeModule_ambient_pid
from sage.modules.free_module import FreeModule_generic
from sage.modules.free_module import FreeModule_submodule_pid
from sage.categories.homset import Hom
from sage.misc.functional import kernel
from sage.groups.matrix_gps.catalog import GL
from sage.libs.gap.libgap import libgap
from sage.interfaces.gap import gap
from sage.groups.matrix_gps.finitely_generated import FinitelyGeneratedMatrixGroup_gap
from sage.matrix.constructor import matrix
from sage.misc.mrange import cartesian_product_iterator
from sage.matrix.special import block_diagonal_matrix
from sage.matrix.special import block_matrix
from sage.structure.element import is_Matrix
from sage.matrix.matrix_space import MatrixSpace
from sage.groups.matrix_gps.finitely_generated import MatrixGroup
from sage.groups.perm_gps.permgroup import load_hap
from sage.arith.misc import xgcd

def GLattice(*args, **kwds):
    r"""
    Create a `G`-lattice: a finite-rank free `\ZZ`-module with an action of a finite group `G`

    INPUT:

    You can define a `G`-lattice by providing any of the following inputs:

    - A group `G` and a list ``im_gens`` of `n \times n` matrices, one for each generator of `G`.

    - A group `G` and a non-negative integer `n`.  Produces the rank `n`
      lattice with trivial `G`-action.

    - A non-negative integer `n`.  As above, with the trivial group.

    - A list ``im_gens`` of `n \times n` matrices.  `G` will be taken to be
      the generated matrix group.

    - A finite matrix group `G`.

    - A permutation group `G`, in which case the action will be by permutation matrices.

    - A list of integers, in which case `G` will be taken to be the abelian group
      with the corresponding invariants.  If `n` is also specified the action will be trivial;
      if a list of matrices ``im_gens`` are given they will define the action;
      otherwise it will be the permutation action.

    The keyword argument ``check`` (default ``True``) determines whether the action
    will be checked to ensure that it is a homomorphism.

    EXAMPLES::

        sage: GLattice(2)
        Ambient lattice of rank 2 with an action by a group of order 1
        sage: GLattice([2, 3], 1)
        Ambient lattice of rank 1 with the trivial action of a group of order 6
        sage: GLattice([2, 3], 1).group()
        Permutation Group with generators [(3,4,5), (1,2)]

    ::

        sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
        sage: act2 = matrix.identity(3)
        sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
        sage: GLattice(G, [act1, act2])
        Ambient lattice of rank 3 with an action by a group of order 6

    ::

        sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
        sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
        sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
        sage: GLattice([m1, m2, m3])
        Ambient lattice of rank 3 with a faithful action by a group of order 8

    ::

        sage: GLattice([2, 3])
        Ambient lattice of rank 5 with a faithful action by a group of order 6

    TESTS::

        sage: GLattice(0)
        Ambient lattice of rank 0 with an action by a group of order 1
    """
    def kwd_set(xname, x):
        if xname in kwds:
            raise TypeError("GLattice() got multiple values for argument '%s'" % xname)
        kwds[xname] = x
    if len(args) == 1:
        x = args[0]
        if isinstance(x, (int, Integer)):
            kwd_set('n', x)
        elif isinstance(x, (list, tuple)):
            if all(isinstance(i, (int, Integer)) for i in x):
                kwd_set('G', x)
            else:
                kwd_set('im_gens', x)
        else:
            kwd_set('G', x)
    elif len(args) == 2:
        x, y = args
        kwd_set('G', x)
        if isinstance(y, (int, Integer)):
            kwd_set('n', y)
        elif isinstance(y, (list, tuple)):
            kwd_set('im_gens', y)
        else:
            raise TypeError("Invalid type for second argument")
    elif len(args) > 2:
        raise TypeError("GLattice() takes 2 positional arguments but %s were given" % (len(args)))

    def process_matrix_group(G):
        iso = libgap(G).IsomorphismPermGroup()
        G = PermutationGroup(iso.Image().GeneratorsOfGroup().sage())
        im_gens = [matrix(i) for i in iso.PreImage(G.gens()).sage()]
        return G, im_gens

    G = kwds.pop('G', None)
    if isinstance(G, FinitelyGeneratedMatrixGroup_gap):
        # Matrix groups implicitly specify the generators
        G, im_gens = process_matrix_group(G)
        kwd_set('im_gens', im_gens) # ensure that im_gens wasn't specified twice
    elif isinstance(G, SymmetricGroup):
        G = PermutationGroup(G.gens(), canonicalize=False)
    elif isinstance(G, (list, tuple)):
        if all(isinstance(i, (int, Integer)) for i in G):
            partial_sums = [1]
            for i in G:
                partial_sums.append(partial_sums[-1] + i)
            G = PermutationGroup([tuple(range(a,b)) for (a,b) in zip(partial_sums[:-1], partial_sums[1:])])
        else:
            raise ValueError("G must be a group or list of integers")
    im_gens = kwds.pop('im_gens', None)
    n = kwds.pop('n', None)
    check = kwds.pop('check', True)
    if kwds:
        raise TypeError("GLattice() got an unexpected keyword argument '%s'" % ("', '".join(kwds)))

    if im_gens is None and n is None:
        # Try to use permutation action to produce an action
        try:
            n = G.largest_moved_point()
            im_gens = [g.matrix() for g in G.gens()]
        except AttributeError:
            raise TypeError("For non-permutation groups, must specify at least one of 'im_gens' and 'n'")
    if G is None and im_gens is None:
        G = PermutationGroup([()])
        im_gens = [matrix.identity(n)]
    elif im_gens is None:
        im_gens = [matrix.identity(n) for g in G.gens()]
    elif G is None:
        G = MatrixGroup(im_gens)
        if G.base_ring() is not ZZ:
            raise ValueError("Generators must be specified with integer entries")
        G, im_gens = process_matrix_group(G)

    # Check consistency
    if n is None:
        n = im_gens[0].nrows()
    if not all(g.nrows() == n and g.ncols() == n for g in im_gens):
        raise ValueError("Inconsistent value of n")
    if len(im_gens) != G.ngens():
        raise ValueError("im_gens must have the same length as the number of generators of G")
    return Lattice_ambient(G, im_gens, check)

def extended_xgcd(lst, result=[ZZ(1)]):
    r"""
    Extension of xgcd to inputs of more than two integers.

    INPUT:

    - ``lst`` -- the list of integers for which we want the gdc and Bezout coefficients.

    - ``result`` -- only used for recursion

    OUTPUT:

    - ``d`` -- the greatest common divisor of ``lst``
    - ``coeffs`` -- a list of coefficients whose inner product with ``lst`` gives ``d``.

    EXAMPLES::

        sage: from sage.modules.glattice import extended_xgcd
        sage: extended_xgcd([6, 20, 15])
        (1, [21, -7, 1])
        sage: extended_xgcd([12, 20, 28, 30])
        (2, [-14, 7, 0, 1])
    """
    if len(lst) == 0:
        return (ZZ(0), [])
    elif len(lst) == 1:
        a = lst[0]
        if a < 0:
            a = -a
            result = [-x for x in result]
        return (a, result)
    else:
        a, b, c = xgcd(lst[0], lst[1])
        r = [b*i for i in result]
        return extended_xgcd([a] + lst[2:], r + [c])

class GAPMap_toGLn(Map):
    r"""
    Sage Map class for a group homomorphism to `GL_n(\ZZ)` in GAP.
    """

    def __init__(self, group, rank, hom):
        r"""
        Construct a map

        INPUT:

        - ``group`` -- the domain of the homomorphism

        - ``rank`` -- the rank of the target matrix group

        - ``hom`` -- the group homomorphism as a libgap object

        EXAMPLES::

            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix(3, [1, 0, 0, 0, 1, 0, 0, 0, 1])
            sage: act = [act1, act2]
            sage: L = GLattice(G, act);
            sage: L._action
            Left action by Full MatrixSpace of 3 by 3 dense matrices over Integer Ring on Ambient lattice of rank 3 with an action by a group of order 6
            with precomposition on left by Composite map:
              From: Permutation Group with generators [(3,4,5), (1,2)]
              To:   Full MatrixSpace of 3 by 3 dense matrices over Integer Ring
              Defn:   Generic map:
                      From: Permutation Group with generators [(3,4,5), (1,2)]
                      To:   General Linear Group of degree 3 over Integer Ring
                    then
                      Coercion morphism:
                      From: General Linear Group of degree 3 over Integer Ring
                      To:   Full MatrixSpace of 3 by 3 dense matrices over Integer Ring
        """
        Map.__init__(self, Hom(group,GL(rank, ZZ)))
        self._morphism = hom

    def _call_(self, x):
        r"""
        Return the action of a specific group element.

        INPUT:

        - ``x`` -- group element (possibly in tuple form) we want the action of.

        EXAMPLES::

            sage: L = GLattice([2, 2])
            sage: a = L._action
            sage: m = a((1, 2))
            sage: m((1, 2, 5, 7))
            (2, 1, 5, 7)
            sage: m(L.basis()[0])
            (0, 1, 0, 0)

        """
        return matrix(self._morphism.Image(x).sage())

###############################################################################
#
# Base class for all lattices
#
###############################################################################

class Lattice_generic(FreeModule_generic):
    r"""
    Generic classes for all lattices

    INPUT:

    - ``G`` -- the permutation group acting on the lattice.

    - ``im_gens`` -- action of the group on the lattice, given as a list of matrices.

    EXAMPLES::

        sage: L = GLattice(SymmetricGroup(3), 5); L
        Ambient lattice of rank 5 with the trivial action of a group of order 6
        sage: a,b,c,d,e = L.basis()

    ::

        sage: L.sublattice([a, b, c+d+e])
        Sublattice of degree 5 and rank 3 with the trivial action of a group of order 6 and echelon basis matrix
        [1 0 0 0 0]
        [0 1 0 0 0]
        [0 0 1 1 1]

    ::

        sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
        sage: act2 = matrix.identity(3)
        sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
        sage: GLattice(G, [act1, act2])
        Ambient lattice of rank 3 with an action by a group of order 6

    ::

        sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
        sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
        sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
        sage: GLattice([m1, m2, m3])
        Ambient lattice of rank 3 with a faithful action by a group of order 8

    ::

        sage: H = MatrixGroup([m1, m2, m3])
        sage: GLattice(H)
        Ambient lattice of rank 3 with a faithful action by a group of order 8
    """
    def __init__(self, G, im_gens, check):
        r"""
        Constructs a generic lattice.

        TESTS::

            sage: TestSuite(GLattice(SymmetricGroup(3), 5)).run()
        """
        self._group = G
        self._generators = G.gens()
        self._action_matrices = im_gens
        self._rank = im_gens[0].nrows()
        FreeModule_generic.__init__(self, ZZ, self._rank, self._rank)
        G = libgap(G)
        GenG = libgap(self._generators)
        Mats = libgap(self._action_matrices)
        if self._rank == 0:
            self._action_morphism = self._GAPMap = None
            self._action = TrivialAction(self._group, self)
        else:
            if self._rank == 1:
                gl = libgap.Group([ [ [ -1 ] ] ])
            else:
                gl = libgap.GL(self._rank,ZZ)
            if check:
                self._action_morphism = libgap.GroupHomomorphismByImages(G, gl, GenG, Mats)
                if libgap.IsBool(self._action_morphism):
                    raise ValueError('The action is not well defined')
            else:
                self._action_morphism = libgap.GroupHomomorphismByImagesNC(G, gl, GenG, Mats)
            self._GAPMap = GAPMap_toGLn(self._group, self._rank, self._action_morphism)
            A = MatrixSpace(ZZ, self._rank).get_action(self)
            self._action = PrecomposedAction(A, self._GAPMap, None)

    def _action_repr(self):
        r"""
        A short string describing how the group acts.

        EXAMPLES::

            sage: GLattice(SymmetricGroup(3), 2)._action_repr()
            'the trivial action of'
            sage: GLattice(SymmetricGroup(3))._action_repr()
            'a faithful action by'
            sage: GLattice(0)._action_repr()
            'an action by'
        """
        if self.rank() == 0 or self.group().order() == 1:
            return "an action by"
        elif self.action_is_trivial():
            return "the trivial action of"
        elif self.action_is_faithful():
            return "a faithful action by"
        else:
            return "an action by"

    def _act(self, g, e):
        r"""
        Computes the action of the group_element on a lattice element.

        INPUT:

        - ``g`` -- an element of the group acting on the lattice.

        - ``e`` -- an element of the lattice we wish to compute the action for.

        EXAMPLES::

            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix.identity(3)
            sage: L1 = GLattice(G, [act1, act2])
            sage: L1._act(L1.group()[1], L1.basis()[0])
            (0, 1, 0)

        ::

            sage: L2 = GLattice(PermutationGroup([(2, 3), (1, 6, 3), (7, 6, 4, 5)]), 1)
            sage: L2._act(L2.group()[1], L2.basis()[0])
            (1)
        """
        return  self._action.act(g,e)



    def stabilizer(self, elt):
        """
        Return the subgroup stabilizing an element or a sublattice

        EXAMPLES::

            sage: H = DihedralGroup(4)
            sage: L = GLattice(H, 1)
            sage: IL = L.induced_lattice(H)
            sage: b = sum(IL.basis())
            sage: IL.stabilizer(b)
            Subgroup generated by [(2,4), (1,2,3,4), (1,3)(2,4)] of (Dihedral group of order 8 as a permutation group)
            sage: SL = IL.zero_sum_sublattice()
            sage: IL.stabilizer(SL)
            Subgroup generated by [(2,4), (1,2,3,4), (1,3)(2,4)] of (Dihedral group of order 8 as a permutation group)
        """
        G = self.group()
        H = []
        if isinstance(elt, SubLattice):
            B = elt.basis()
            test = True
            for g in G:
                for b in B:
                    if self._action(g)(b) != b:
                        test = False
                if test:
                    H.append(g)
                test = True
        else:
            for g in G:
                if self._action(g)(elt) == elt:
                    H.append(g)
        HG = PermutationGroup(H)
        for g in G.subgroups(): 
            if HG == g:
                return g


    def orbit(self, elt, subgroup = None, build = False):
        """
        Return the orbit of an element either as list of elements or the sublattice generated by the orbit.

        INPUT:

        - ``elt`` -- The element we want to compute the orbit of.

        - ``subgroup`` -- Subgroup under which we desire to take the orbit. By default it is ``None`` which 
          corresponds to the full group.

        - `` build`` -- Boolean (default ``False``). If ``True``, the method will return a sublattice generated by the
          orbit.

        EXAMPLES::

            sage: L = GLattice([2, 2])
            sage: [a, b, c, d] = L.basis()
            sage: L.orbit(c)
            [(0, 0, 1, 0), (0, 0, 0, 1)]
            sage: L.orbit(c, L.group().subgroups()[1])
            [(0, 0, 1, 0)]
            sage: L.orbit(a+b, None, True)
            Sublattice of degree 4 and rank 1 with a faithful action by a group of order 4 and echelon basis matrix
            [1 1 0 0]
        """
        o = []
        subgroup = self.group() if subgroup == None else subgroup
        for g in subgroup:
            e = self._action(g)(elt)
            if not(e in o):
                o.append(e)
        return self.sublattice(o) if build else o  

    def orbit_permutation_cover(self, elt):
        """
        Create an ambient permutation lattice freely spanned by elements of an orbit, and output a 
        surjective morphism onto the orbit. The output is a pair consisting of the permutation lattice
        and the surjection.

        EXAMPLES::

            sage: L = GLattice([2])
            sage: [a, b] = L.basis()
            sage: QL = L.quotient_lattice(L.sublattice([a+b]))
            sage: QL._action_matrices
            [[-1]]
            sage: [x] = QL.basis()
            sage: [P, h] = QL.orbit_permutation_cover(x); [P, h]
            [Ambient lattice of rank 2 with a faithful action by a group of order 2,
             Lattice morphism defined by the left action of the matrix
             [ 1|-1]
             Domain: Ambient lattice of rank 2 with a faithful action by a group of order 2
             Codomain: Ambient lattice of rank 1 with a faithful action by a group of order 2]
            sage: h.is_surjective()
            True
            sage: h.domain()
            Ambient lattice of rank 2 with a faithful action by a group of order 2
            sage: P._action_matrices
            [
            [0 1]
            [1 0]
            ]
        """
        o = self.orbit(elt)
        rank = len(o)
        G = self.group()
        action = []
        from sage.matrix.special import zero_matrix
        for g in G.gens(): 
            mat = zero_matrix(rank)
            for e in range(len(o)):
                index = o.index(self._action(g)(o[e]))
                mat[index, e] = 1
            action.append(mat)
        Lat = GLattice(G, action)

        morphism_mat = block_matrix(1, rank, [b.column() for b in o])
        morphism = Lat.left_morphism(morphism_mat, self)
        return [morphism.domain(), morphism]

    def diagonal_embedding(self):
        """
        Return the diagonal embedding into the direct sum of the lattice with itself.

        EXAMPLES::

            sage: L = GLattice([2, 2])
            sage: h = L.diagonal_embedding(); h
            Lattice morphism defined by the left action of the matrix
            [1 0 0 0]
            [0 1 0 0]
            [0 0 1 0]
            [0 0 0 1]
            [-------]
            [1 0 0 0]
            [0 1 0 0]
            [0 0 1 0]
            [0 0 0 1]
            Domain: Ambient lattice of rank 4 with a faithful action by a group of order 4
            Codomain: Ambient lattice of rank 8 with a faithful action by a group of order 4
            sage: h.is_injective()
            True
        """
        from sage.matrix.special import identity_matrix
        lat = self.direct_sum(self)
        r = self.rank()
        i = identity_matrix(r)
        m = block_matrix(2, [i, i])
        return self.left_morphism(m, lat)


    def surjection_from_square(self, side="right"):
        """
        Return the natural map from the direct sum of the lattice with itself given by sending the direct sum
        to the sum.

        EXAMPLES::

            sage: L = GLattice([2, 2])
            sage: h = L.surjection_from_square(); h
            Lattice morphism defined by the left action of the matrix
            [1 0 0 0|1 0 0 0]
            [0 1 0 0|0 1 0 0]
            [0 0 1 0|0 0 1 0]
            [0 0 0 1|0 0 0 1]
            Domain: Ambient lattice of rank 8 with a faithful action by a group of order 4
            Codomain: Ambient lattice of rank 4 with a faithful action by a group of order 4
            sage: h.is_surjective()
            True
            sage: h.is_injective()
            False
            sage: h.matrix() == L.dual().diagonal_embedding().dual().matrix()
            True
        """
        from sage.matrix.special import identity_matrix
        lat = self.direct_sum(self)
        r = self.rank()
        i = identity_matrix(r)
        m = block_matrix(1, [i, i])
        if side == "left":
            m = m.transpose()
        return lat.hom(m, self, side=side)

    def permutation_cover(self):
        """
        Create a permutation lattice (not of minimal dimension) and return a surjective morphism from that lattice
        to self.

        EXAMPLES::

            sage: L = GLattice([2, 2])
            sage: [a, b, c, d] = L.basis()
            sage: QL = L.quotient_lattice(L.sublattice([a+b]))
            sage: QL
            Ambient lattice of rank 3 with a faithful action by a group of order 4
            sage: QL.permutation_cover()
            [Ambient lattice of rank 4 with a faithful action by a group of order 4,
             Lattice morphism defined by the left action of the matrix
             [ 1  0| 0  0]
             [ 0  1| 0  0]
             [ 0  0| 1 -1]
             Domain: Ambient lattice of rank 4 with a faithful action by a group of order 4
             Codomain: Ambient lattice of rank 3 with a faithful action by a group of order 4]
            sage: [P, h] = _
            sage: P._action_matrices
            [
            [0 1|0 0]  [1 0|0 0]
            [1 0|0 0]  [0 1|0 0]
            [---+---]  [---+---]
            [0 0|1 0]  [0 0|0 1]
            [0 0|0 1], [0 0|1 0]
            ]
            sage: h.is_surjective()
            True
        """
        orbits = []
        representatives = []
        from sage.modules.free_module import span
        for b in self.basis():
            if not(b in span(orbits, ZZ)):
                orbits += self.orbit(b)
                representatives.append(b)

        initial_map = self.orbit_permutation_cover(representatives[0])[1]
        morphisms = [self.orbit_permutation_cover(r)[1] for r in representatives[1:]]
        hom = initial_map.exterior_sum(morphisms, codomain_ext = False) 
        return [hom.domain(), hom]

    def left_morphism(self, mat, codomain=None):
        """
        Create a homomorphism of lattices. 

        INPUT:

        - ``mat`` -- matrix representing the linear transformation.

        - ``codomain`` -- codomain of the homomorphism, if left empty it will be assumed to be an endomorphism.

        EXAMPLES::

            sage: G = SymmetricGroup(3)
            sage: L1 = GLattice(G)
            sage: L2 = GLattice(G,3)
            sage: h1 = L1.left_morphism(identity_matrix(3),L2); h1
            Traceback (most recent call last):
            ...
            TypeError: The morphism does not preserve the action of the group
            sage: h2 = L1.left_morphism(identity_matrix(3)); h2
            Lattice endomorphism defined by the left action of the matrix
            [1 0 0]
            [0 1 0]
            [0 0 1]
            Domain: Ambient lattice of rank 3 with a faithful action by a group of order 6
            sage: m = matrix(3, [1, 1, 1, 1, 1, 1, 1, 1, 1])
            sage: h3 = L2.left_morphism(m,L1); h3
            Lattice endomorphism defined by the left action of the matrix
            [1 1 1]
            [1 1 1]
            [1 1 1]
            Domain: Ambient lattice of rank 3 with the trivial action of a group of order 6
        """

        return self.hom(mat, codomain, side="right")

    def group(self):
        r"""
        Return the group acting on the lattice.

        EXAMPLES::

            sage: L1 = GLattice(SymmetricGroup(3), 5)
            sage: L1.group()
            Permutation Group with generators [(1,2,3), (1,2)]

        ::

            sage: L2 = GLattice(PermutationGroup([(2, 3), (1, 6, 3), (7, 6, 4, 5)]), 1)
            sage: L2.group()
            Permutation Group with generators [(4,5,7,6), (2,3), (1,6,3)]

        ::

            sage: L3 = GLattice([-matrix.identity(3)])
            sage: L3.group()
            Permutation Group with generators [(1,2)]
        """
        return self._group

    def action_matrix(self, g):
        """
        Matrix through which the element in the input acts.

        INPUT:

        - ``g`` -- element of the group acting on self.

        EXAMPLES::

            sage: L = GLattice([3])
            sage: G = L.group()
            sage: g = G[1]
            sage: L.action_matrix(g)
            [0 1 0]
            [0 0 1]
            [1 0 0]
        """
        return matrix(self._action_morphism.Image(g))

    def action_is_trivial(self):
        r"""
        Whether the group acts trivially.

        EXAMPLES::

            sage: L1 = GLattice(SymmetricGroup(3), 5)
            sage: L1.action_is_trivial()
            True

            sage: L2 = GLattice([-matrix.identity(3)])
            sage: L2.action_is_trivial()
            False
        """
        return all(A == 1 for A in self._action_matrices)

    def action_is_faithful(self):
        r"""
        Whether the group acts faithfully (the associated map to `GL(n, \ZZ)` is injective).

        EXAMPLES::

            sage: L1 = GLattice(SymmetricGroup(3), 2)
            sage: L1.action_is_faithful()
            False

            sage: L2 = GLattice([-matrix.identity(3)])
            sage: L2.action_is_faithful()
            True
        """
        if self._rank == 0:
            return self.group().order() == 1
        else:
            return bool(self._GAPMap._morphism.IsInjective())

    def action_kernel(self):
        """
        The kernel of the action of the group on the lattice.

        EXAMPLES::

            sage: L1 = GLattice([3]); L1
            Ambient lattice of rank 3 with a faithful action by a group of order 3
            sage: L1.action_kernel()
            Subgroup generated by [()] of (Permutation Group with generators [(1,2,3)])
            sage: L2 = GLattice([3], 3); L2
            Ambient lattice of rank 3 with the trivial action of a group of order 3
            sage: L2.action_kernel()
            Subgroup generated by [(1,2,3)] of (Permutation Group with generators [(1,2,3)])

        ::

            sage: H = DihedralGroup(4)
            sage: L = GLattice(H, 1)
            sage: IL = L.induced_lattice(H)
            sage: IL.action_kernel()
            Subgroup generated by [(1,2,3,4), (1,4)(2,3)] of (Dihedral group of order 8 as a permutation group)
        """
        # TODO: Need to return a Galois subgroup if self._group is a Galois group
        G = PermutationGroup(gap_group=self._GAPMap._morphism.Kernel())
        return self.group().subgroup(G.gens())

    def display_action(self):
        r"""
        Shows information about the group and its action on the lattice.

        EXAMPLES::

            sage: L = GLattice([2, 3])
            sage: L.display_action()
            The group of order 6 generated by permutations [(3,4,5), (1,2)] acts as follows:
            (3,4,5) acts via [1, 0, 0, 0, 0]
                             [0, 1, 0, 0, 0]
                             [0, 0, 0, 1, 0]
                             [0, 0, 0, 0, 1]
                             [0, 0, 1, 0, 0]
            (1,2) acts via [0, 1, 0, 0, 0]
                           [1, 0, 0, 0, 0]
                           [0, 0, 1, 0, 0]
                           [0, 0, 0, 1, 0]
                           [0, 0, 0, 0, 1]
        """

        Ggen = self.group().gens()
        print("The group of order %s generated by permutations %s acts as follows: " % (
            self.group().order(), Ggen))

        for g, a in zip(Ggen, self._action_matrices):
            print("%s acts via %s" % (g, list(a[0])))
            for i in range(1, a.nrows()):
                print(" " * (len(str(g)) + 10) + str(list(a[i])))

    def subgroup_lattice(self, subgp):
        r"""
        Changes the group acting on the lattice to a subgroup.

        INPUT:

        - ``subgp`` -- the subgroup we wish to restrict the lattice to

        EXAMPLES::

            sage: G = SymmetricGroup(4)
            sage: H = DihedralGroup(4)
            sage: L = GLattice(G, 5)
            sage: M = L.subgroup_lattice(H); M
            Ambient lattice of rank 5 with the trivial action of a group of order 8
            sage: M._group
            Dihedral group of order 8 as a permutation group

        ::

            sage: G = SymmetricGroup(3)
            sage: H = CyclicPermutationGroup(2)
            sage: m1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: m2 = matrix(3, [0, 1, 0, 1, 0, 0, 0, 0, 1])
            sage: L = GLattice(G, [m1, m2])
            sage: a,b,c = L.basis()
            sage: SL = L.sublattice([a+b+c])
            sage: SL2 = SL.subgroup_lattice(H); SL2
            Sublattice of degree 3 and rank 1 with a faithful action by a group of order 2 and echelon basis matrix
            [1 1 1]
            sage: SL2._group
            Cyclic group of order 2 as a permutation group
            sage: SL2._action_matrices
            [
            [0 1 0]
            [1 0 0]
            [0 0 1]
            ]

        This time we can see that inducing this lattice back to ``G`` we
        get a lattice isomorphic to ``L``::

            sage: SL3 = SL2.induced_lattice(G)
            sage: SL3._action_matrices
            [
            [0|0|1]  [1|0|0]
            [-+-+-]  [-+-+-]
            [1|0|0]  [0|0|1]
            [-+-+-]  [-+-+-]
            [0|1|0], [0|1|0]
            ]

        ::

            sage: G = SymmetricGroup(3)
            sage: H = CyclicPermutationGroup(3)
            sage: m1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: m2 = matrix(3, [0, 1, 0, 1, 0, 0, 0, 0, 1])
            sage: L = GLattice(G, [m1, m2])
            sage: L1 = GLattice(G, [m1, m2])

        ::

            sage: L2 = L1.subgroup_lattice(H); L2
            Ambient lattice of rank 3 with a faithful action by a group of order 3
            sage: L2._group
            Cyclic group of order 3 as a permutation group
            sage: L2._action_matrices
            [
            [0 1 0]
            [0 0 1]
            [1 0 0]
            ]

        Now we induce the lattice back to ``S_3`` and check that we get different cohomologies::

            sage: L3 = L2.induced_lattice(G)
            sage: L3._action_matrices
            [
            [0 1 0|0 0 0]  [0 0 0|0 0 1]
            [0 0 1|0 0 0]  [0 0 0|1 0 0]
            [1 0 0|0 0 0]  [0 0 0|0 1 0]
            [-----+-----]  [-----+-----]
            [0 0 0|0 0 1]  [0 1 0|0 0 0]
            [0 0 0|1 0 0]  [0 0 1|0 0 0]
            [0 0 0|0 1 0], [1 0 0|0 0 0]
            ]
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(L1.tate_cohomology(i))) # optional - gap_packages
            H^-5:  []
            H^-4:  [2]
            H^-3:  []
            H^-2:  [2]
            H^-1:  []
            H^0:  [2]
            H^1:  []
            H^2:  [2]
            H^3:  []
            H^4:  [2]
            H^5:  []
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(L3.tate_cohomology(i))) # optional - gap_packages
            H^-5:  []
            H^-4:  []
            H^-3:  []
            H^-2:  []
            H^-1:  []
            H^0:  []
            H^1:  []
            H^2:  []
            H^3:  []
            H^4:  []
            H^5:  []

        TESTS::

            sage: G = SymmetricGroup(3)
            sage: H = CyclicPermutationGroup(3)
            sage: L = GLattice(G, 0)
            sage: L.subgroup_lattice(H)
            Ambient lattice of rank 0 with an action by a group of order 3
        """
        lat = self.ambient_lattice()
        if lat._rank == 0:
            amb = GLattice(subgp, 0)
        else:
            mor = self._action_morphism
            I = [mor.Image(i).sage() for i in subgp.gens()]
            a = [matrix(i) for i in I]
            amb = GLattice(subgp, a)
        if self.is_ambient():
            return amb
        else:
            return amb.sublattice(self.basis(), check=False)

    def direct_sum(self, lat, param="interior"):
        r"""
        Takes a lattice and outputs the direct sum of the two lattices.

        INPUT:

        - ``lat`` -- lattice we wish to sum with the current lattice.

        - ``param`` -- parameter to determine if we want to compute the interior or exterior direct sum.
          The two possible choices are ``interior`` and ``exterior``. It is by default ``interior``, which requires
          the two lattices to be acted on by the same group.

        EXAMPLES::

            sage: Lat = GLattice([2], 1)
            sage: Lat._action_matrices
            [[1]]
            sage: G = Lat.group()
            sage: Lat2 = GLattice(1).induced_lattice(G)
            sage: Lat2._action_matrices
            [
            [0|1]
            [-+-]
            [1|0]
            ]
            sage: L = Lat.direct_sum(Lat2); L; L._action_matrices
            Ambient lattice of rank 3 with a faithful action by a group of order 2
            [
            [1|0 0]
            [-+---]
            [0|0 1]
            [0|1 0]
            ]

        ::

            sage: L1 = GLattice(SymmetricGroup(3))
            sage: L2 = GLattice(CyclicPermutationGroup(4))
            sage: L = L1.direct_sum(L2, "exterior")
            sage: L = L1.direct_sum(L2, "exterior"); L; L._action_matrices
            Ambient lattice of rank 7 with a faithful action by a group of order 24
            [
            [1 0 0|0 0 0 0]  [0 1 0|0 0 0 0]  [0 1 0|0 0 0 0]
            [0 1 0|0 0 0 0]  [1 0 0|0 0 0 0]  [0 0 1|0 0 0 0]
            [0 0 1|0 0 0 0]  [0 0 1|0 0 0 0]  [1 0 0|0 0 0 0]
            [-----+-------]  [-----+-------]  [-----+-------]
            [0 0 0|0 1 0 0]  [0 0 0|1 0 0 0]  [0 0 0|1 0 0 0]
            [0 0 0|0 0 1 0]  [0 0 0|0 1 0 0]  [0 0 0|0 1 0 0]
            [0 0 0|0 0 0 1]  [0 0 0|0 0 1 0]  [0 0 0|0 0 1 0]
            [0 0 0|1 0 0 0], [0 0 0|0 0 0 1], [0 0 0|0 0 0 1]
            ]
        """
        if isinstance(lat, list):
            if len(lat) == 0:
                return self
            else:
                L = self.direct_sum(lat[0], param)
                return L.direct_sum(lat[1:], param)
        else:
            if param == "interior":
                g = self.group()
                act = [block_diagonal_matrix([A, B])
                       for (A, B) in zip(self._action_matrices, lat._action_matrices)]
                return Lattice_ambient(g, act)
            elif param == "exterior":
                g1 = self.group()
                g2 = lat.group()
                [G, inj1, inj2, proj1, proj2] = g1.direct_product(g2)
                hom1 = self._action_morphism
                hom2 = lat._action_morphism
                action = [block_diagonal_matrix(matrix(hom1.Image(proj1(g))),matrix(hom2.Image(proj2(g)))) for g in G.gens()]
                return GLattice(G,action)
            else:
                raise ValueError("the last argument must be either 'interior' or 'exterior'")

    def ambient_lattice(self):
        r"""
        Return this lattice; for compatibility with the corresponding method of sublattices.

        EXAMPLES::

            sage: L = GLattice([2, 3])
            sage: L.ambient_lattice() is L
            True
            sage: ZL = L.zero_sum_sublattice()
            sage: ZL.ambient_lattice()
            Ambient lattice of rank 5 with a faithful action by a group of order 6
            sage: ZL.ambient_lattice() is L
            True
        """
        return self


    def fixed_sublattice(self, subgp = None):
        r"""
        Compute the sublattice of elements fixed by the group, or a specified subgroup.

        INPUT:

        - ``subgp`` -- the subgroup we want to compute fixed vectors of. If left empty, the 
          method will return the fixed vectors of the whole group. If the subgroup is not normal
          then the submodule of fixed vectors will fail to be a GLattice, so the output will be a 
          free module. 

        EXAMPLES::

            sage: G = PermutationGroup([(1, 2),(3, 4),(5, 6),(7, 8)])
            sage: L = GLattice(1)
            sage: IL = L.induced_lattice(G)
            sage: ROS = L.norm_one_restriction_of_scalars(G)

        ::

            sage: IL.fixed_sublattice()
            Sublattice of degree 16 and rank 1 with a faithful action by a group of order 16 and echelon basis matrix
            [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]
            sage: ROS.fixed_sublattice()
            Sublattice of degree 15 and rank 0 with an action by a group of order 16 and echelon basis matrix
            []
            sage: L.fixed_sublattice()
            Sublattice of degree 1 and rank 1 with an action by a group of order 1 and echelon basis matrix
            [1]

        ::

            sage: G = SymmetricGroup(3)
            sage: [H1,H2] = [G.subgroups()[0],G.subgroups()[1]]
            sage: L = GLattice(G)
            sage: L.fixed_sublattice()
            Sublattice of degree 3 and rank 1 with a faithful action by a group of order 6 and echelon basis matrix
            [1 1 1]
            sage: L.fixed_sublattice(H1)
            Sublattice of degree 3 and rank 3 with a faithful action by a group of order 6 and echelon basis matrix
            [1 0 0]
            [0 1 0]
            [0 0 1]
            sage: L.fixed_sublattice(H2)
            Free module of degree 3 and rank 2 over Integer Ring
            Echelon basis matrix:
            [1 0 0]
            [0 1 1]
        """
        if subgp is None:
            a = self._action_matrices
        else:
            mor = self._action_morphism
            I = [mor.Image(i).sage() for i in subgp.gens()]
            a = [matrix(i) for i in I]
        kers = [kernel((m - matrix.identity(self._rank)).transpose()) for m in a]
        res = self
        for K in kers:
            res = res.intersection(K)
        try:
            return SubLattice(self, res.basis())
        except ValueError:
            return res


    def complete_submodule(self, submod):
        """
        Complete a submodule into a sublattice by adding the orbits of basis vectors. 

        INPUT:

        - ``submod`` -- a submodule we want to complete into a sublattice.

        EXAMPLES::

            sage: L = GLattice([2, 2])
            sage: [a, b, c, d] = L.basis()
            sage: SL = L.submodule([a+b+c])
            sage: L.complete_submodule(SL)
            Sublattice of degree 4 and rank 2 with a faithful action by a group of order 4 and echelon basis matrix
            [ 1  1  0  1]
            [ 0  0  1 -1]
        """

        B = submod.basis()
        oB = []
        for g in self.group():
            for b in B:
                oB.append(self._action(g)(b))
        return self.sublattice(oB)

    def pullback_lattice(self, hom):
        r"""
        Given a group homomorphism with target in the associated group of the lattice,
        we create a lattice with the pullback action.

        INPUT:

        - ``hom`` -- GAP group homomorphism.

        EXAMPLES::

            sage: G = PermutationGroup([(1,2,3,4),(1,2)])
            sage: Gg = libgap(G)
            sage: Hom = gap.GroupHomomorphismByImages(Gg,Gg,G.gens(),G.gens())
            sage: L = GLattice(G, 3)
            sage: M = L.pullback_lattice(Hom); M
            Ambient lattice of rank 3 with the trivial action of a group of order 24
            sage: M._action_matrices
            [
            [1 0 0]  [1 0 0]
            [0 1 0]  [0 1 0]
            [0 0 1], [0 0 1]
            ]

        ::

            sage: G = gap.SymmetricGroup(3)
            sage: H = gap.SymmetricGroup(2)
            sage: Ggen = gap.GeneratorsOfGroup(G)
            sage: [a] = gap.GeneratorsOfGroup(H)
            sage: hom = gap.GroupHomomorphismByImages(G, H, Ggen, [a*a, a])
            sage: L = GLattice(SymmetricGroup(2)); L._action_matrices
            [
            [0 1]
            [1 0]
            ]
            sage: EL=L.pullback_lattice(hom); EL._action_matrices
            [
            [0 1]  [1 0]
            [1 0], [0 1]
            ]
        """
        Ggap = hom.Source()
        G = PermutationGroup(Ggap.GeneratorsOfGroup().sage())
        if self._rank == 0:
            a = [matrix(ZZ, 0) for g in G.gens()]
        else:
            mor = self._action_morphism
            I = [hom.Image(i) for i in G.gens()]
            a = [matrix(mor.Image(i).sage()) for i in I]
        return Lattice_ambient(G, a)


    def isomorphic_ambient_lattice(self):
        r"""
        Return an isomorphic ambient lattice, which is this lattice for ambient lattices.

        EXAMPLES::

            sage: L = GLattice(1)
            sage: LL = L.isomorphic_ambient_lattice(); LL
            Ambient lattice of rank 1 with an action by a group of order 1
            sage: LL is L
            True

        ::

            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix.identity(3)
            sage: L1 = GLattice(G, [act1, act2])

        ::

            sage: x, y, z = L1.basis()
            sage: SL = L1.sublattice([x-y, y-z])
            sage: L1.isomorphic_ambient_lattice() is L1
            True
            sage: X = SL.isomorphic_ambient_lattice(); X
            Ambient lattice of rank 2 with an action by a group of order 6
            sage: X._action_matrices
            [
            [ 0  1]  [1 0]
            [-1 -1], [0 1]
            ]

        ::

            sage: L = GLattice(SymmetricGroup(2))
            sage: x, y = L.basis()
            sage: SL = L.sublattice([x+y])
            sage: X = SL.isomorphic_ambient_lattice(); X
            Ambient lattice of rank 1 with the trivial action of a group of order 2
            sage: X.basis()
            [
            (1)
            ]
            sage: X._action_matrices
            [[1]]
        """
        return self

    def GAPMatrixGroup(self):
        r"""
        The image of the action of the group inside
        `GL_n(\ZZ)` as a GAP group.

        EXAMPLES::

            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix.identity(3)
            sage: L1 = GLattice(G, [act1, act2])
            sage: L1.GAPMatrixGroup()
            Group([ [ [ 0, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 0 ] ], [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] ])

        ::

            sage: L2 = GLattice(PermutationGroup([(2, 3), (1, 6, 3), (7, 6, 4, 5)]), 1)
            sage: L2.GAPMatrixGroup()
            Group([ [ [ 1 ] ], [ [ 1 ] ], [ [ 1 ] ] ])

        ::

            sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
            sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
            sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
            sage: L3 = GLattice([m1, m2, m3])
            sage: GapG = L3.GAPMatrixGroup(); GapG
            <matrix group with 3 generators>
            sage: GapG.GeneratorsOfGroup()
            [ [ [ -1, 0, 0 ], [ 0, -1, 0 ], [ 0, 0, -1 ] ], [ [ 0, 0, 1 ], [ -1, -1, -1 ], [ 1, 0, 0 ] ], [ [ 0, 1, 0 ], [ 1, 0, 0 ], [ -1, -1, -1 ] ] ]

        Note that this method will fail on lattices of rank 0::

            sage: GLattice(0).GAPMatrixGroup()
            Traceback (most recent call last):
            ...
            ValueError: GAP does not support groups of 0x0 matrices
        """
        if self._rank == 0:
            raise ValueError("GAP does not support groups of 0x0 matrices")
        f = self._GAPMap
        return f._morphism.Image()

    def colattice(self):
        r"""
        Outputs the lattice with action of the same group, but its action is
        composed with the inverse transpose automorphism of `GL_n(\ZZ)`

        EXAMPLES::

            sage: L = GLattice(CyclicPermutationGroup(6), [matrix([[0, 1], [-1, -1]])])
            sage: L._action_matrices
            [
            [ 0  1]
            [-1 -1]
            ]
            sage: L.colattice()._action_matrices
            [
            [-1  1]
            [-1  0]
            ]
        """

        if self.rank() == self.degree():
            newacts = [i.inverse().transpose() for i in self._action_matrices]
            lat = Lattice_ambient(self._group, newacts)
            return lat
        else:
            return self.isomorphic_ambient_lattice().colattice()

    def dual(self):
        """
        Return the colattice, see :meth:`colattice`.

        EXAMPLES::

            sage: L = GLattice([6], [matrix([[0, 1], [-1, -1]])])
            sage: L.dual() == L.colattice()                                                 
            True
        """
        return self.colattice()

    def tate_cohomology(self, n, cocycles=False):
        r"""
        Return the isomorphism type of the `n`-th Tate cohomology group.

        This is a slight adaptation of Hoshi and Yamasaki's GAP code ([HY2017]_).

        INPUT:

        - ``n`` -- the index of the cohomology group to compute.

        - ``cocycles`` -- if ``True``, will also return generating
          cocycles for the cohomology group as concatenated vectors
          of images of each group element (only supported for `n=1`).

        EXAMPLES::

            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix.identity(3)
            sage: L1 = GLattice(G, [act1, act2])
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(L1.tate_cohomology(i))) # optional - gap_packages
            H^-5:  []
            H^-4:  [2]
            H^-3:  []
            H^-2:  [2]
            H^-1:  []
            H^0:  [2]
            H^1:  []
            H^2:  [2]
            H^3:  []
            H^4:  [2]
            H^5:  []

        ::

            sage: L2 = GLattice(SymmetricGroup(3), 4)
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(L2.tate_cohomology(i))) # optional - gap_packages
            H^-5:  []
            H^-4:  [6, 6, 6, 6]
            H^-3:  []
            H^-2:  [2, 2, 2, 2]
            H^-1:  []
            H^0:  [6, 6, 6, 6]
            H^1:  []
            H^2:  [2, 2, 2, 2]
            H^3:  []
            H^4:  [6, 6, 6, 6]
            H^5:  []

        ::

            sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
            sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
            sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
            sage: L3 = GLattice([m1, m2, m3])
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(L3.tate_cohomology(i))) # optional - gap_packages
            H^-5:  [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
            H^-4:  [2, 2, 2, 2, 2, 2, 2, 2]
            H^-3:  [2, 2, 2, 2, 2, 2]
            H^-2:  [2, 2, 2]
            H^-1:  [2]
            H^0:  []
            H^1:  [2]
            H^2:  [2]
            H^3:  [2, 2, 2]
            H^4:  [2, 2, 2, 2]
            H^5:  [2, 2, 2, 2, 2, 2, 2]

        ::

            sage: G = CyclicPermutationGroup(58)
            sage: mat = matrix(2, [0, 1, 1, 0])
            sage: L = GLattice(G, [mat])
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(L.tate_cohomology(i))) # optional - gap_packages
            H^-5:  []
            H^-4:  [29]
            H^-3:  []
            H^-2:  [29]
            H^-1:  []
            H^0:  [29]
            H^1:  []
            H^2:  [29]
            H^3:  []
            H^4:  [29]
            H^5:  []

        ::

            sage: L = GLattice(DihedralGroup(4), 4)
            sage: SL = L.zero_sum_sublattice()
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(SL.tate_cohomology(i))) # optional - gap_packages
            H^-5:  [2, 2, 2, 2, 2, 2]
            H^-4:  [2, 2, 2, 2, 2, 2, 4, 4, 4]
            H^-3:  [2, 2, 2]
            H^-2:  [2, 2, 2, 2, 2, 2]
            H^-1:  []
            H^0:  [8, 8, 8]
            H^1:  []
            H^2:  [2, 2, 2, 2, 2, 2]
            H^3:  [2, 2, 2]
            H^4:  [2, 2, 2, 2, 2, 2, 4, 4, 4]
            H^5:  [2, 2, 2, 2, 2, 2]

        ::

            sage: G = DihedralGroup(4)
            sage: m1 = matrix(2, [0, 1, 1, 0])
            sage: m2 = -matrix.identity(2)
            sage: L = GLattice(G, [m1, m2])
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(L.tate_cohomology(i))) # optional - gap_packages
            H^-5:  [2, 2, 2]
            H^-4:  [2, 2]
            H^-3:  [2, 2]
            H^-2:  [2]
            H^-1:  [2]
            H^0:  []
            H^1:  [2]
            H^2:  [2]
            H^3:  [2, 2]
            H^4:  [2, 2]
            H^5:  [2, 2, 2]
            sage: SL1 = L.zero_sum_sublattice()
            sage: a,b = L.basis()
            sage: SL2 = L.sublattice([a+b])
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(SL1.tate_cohomology(i))) # optional - gap_packages
            H^-5:  [2, 2, 2]
            H^-4:  [2, 2]
            H^-3:  [2, 2]
            H^-2:  [2]
            H^-1:  [2]
            H^0:  []
            H^1:  [2]
            H^2:  [2]
            H^3:  [2, 2]
            H^4:  [2, 2]
            H^5:  [2, 2, 2]
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(SL2.tate_cohomology(i))) # optional - gap_packages
            H^-5:  [2, 2, 2]
            H^-4:  [2, 2]
            H^-3:  [2, 2]
            H^-2:  [4]
            H^-1:  [2]
            H^0:  []
            H^1:  [2]
            H^2:  [4]
            H^3:  [2, 2]
            H^4:  [2, 2]
            H^5:  [2, 2, 2]
        """
        if cocycles:
            if n != 1:
                raise NotImplementedError("cocycles option only supported for n=1")
            return self.first_cohomology_group()
        if self._rank == 0:
            return []
        self = self.isomorphic_ambient_lattice()
        MG = self.GAPMatrixGroup()
        G = libgap(self.group())
        if n == 0:
            M = matrix.zero(self._rank)
            Lst = [libgap(i) for i in self._group]
            for i in Lst:
                M += matrix(self._action_morphism.Image(i).sage())
            #M = matrix(libgap.Sum(MG).sage())
            S = M.smith_form(False, True)
            R = S.rank()
            diags = [S[i][i] for i in range(R)]
            return [ZZ(a) for a in diags if a > 1]
        elif n == -1:
            m = libgap([])
            for i in MG.GeneratorsOfGroup():
                m = libgap.Concatenation(m, i - MG.Identity())
            ms = matrix(m.sage())
            s = ms.smith_form(False, True)
            r = s.rank()
            diags = libgap([s[i][i] for i in range(r)])
            return [ZZ(a) for a in diags if a > 1]
        else:
            load_hap()
            if self._rank == 1:
                gl = libgap.Group([ [ [ -1 ] ] ])
            else:
                gl = libgap.GL(self._rank, ZZ)
            mor = libgap.GroupHomomorphismByImages(G, gl, gap(self.group().gens()), gap(self._action_matrices))
            if n > 0:
                #This computes the standard resolution of G in HAP
                R = libgap.ResolutionFiniteGroup(G, n + 1)
                #Then applies the map to the action to the resolution
                TR = libgap.HomToIntegralModule(R, mor)
                return libgap.Cohomology(TR, n).sage()
            else:
                R = libgap.ResolutionFiniteGroup(G, -n)
                TR = libgap.TensorWithIntegralModule(R, mor)
                return libgap.Homology(TR, -n - 1).sage()

    def first_coboundary_space(self):
        r"""
        Return the space of 1-coboundaries of the group with coefficient in the lattice.

        The coboundaries are vectors of size `rn`, where `r` is the rank of the lattice
        and `n` is the order of the group.
        It is the concatenation of images of each group element.

        EXAMPLES::

            sage: G = PermutationGroup([(1, 2, 3),(4, 5)])
            sage: GM = GLattice(1)
            sage: L = GM.norm_one_restriction_of_scalars(G)
            sage: CB = L.first_coboundary_space(); CB
            Free module of degree 30 and rank 5 over Integer Ring
            Echelon basis matrix:
            [ 0  0  0  0  0  1  1  0  2  2  0  1  1  2  2  0 -1  0  1  0  0 -1 -1  1  1 -1  0  0  0  1]
            [ 0  0  0  0  0  0  2  0  2  2  0  2  1  1  2  0  0 -1  1  0  1  1  0  2  2 -1  1  0  0  0]
            [ 0  0  0  0  0  0  0  1 -1  0  0  0  1  0 -1  1  1  2  1  1 -1  0  1  0  0  0 -1  1  0  0]
            [ 0  0  0  0  0  0  0  0  0  0  1  1  2  2  0  1  1  2  2  0 -1 -1  1  1  0 -1 -1  1  1  0]
            [ 0  0  0  0  0  0  0  0  0  0  0  0  3  3  0  0  0  3  3  0 -3 -3  0  0  0 -3 -3  0  0  0]
            sage: CC = L.first_cocycle_space();
            sage: CC.quotient(CB)
            Finitely generated module V/W over Integer Ring with invariants (6)

        Here computing the coboundaries lets us compute the first cohomology group.
        The last line tells us this cohomology group is `\ZZ/6\ZZ`.  We can check
        that this agrees with the result computed by the :meth:`tate_cohomology` method::

            sage: L.tate_cohomology(1) # optional - gap_packages
            [6]
        """

        lat = self.isomorphic_ambient_lattice()
        r = lat.rank()
        group = lat.group()
        grouplist = list(group)
        Module = FreeModule_ambient_pid(ZZ, r*group.order())
        coboundary_basis = []
        if r != 0:
            actionmat = [matrix(lat._action_morphism.Image(g).sage()) for g in grouplist]
            B = lat.basis()
            if not grouplist[0] == group.identity():
                grouplist = [group.identity()] + grouplist.remove(group.identity())
            for b in B:
                l = []
                for i in actionmat:
                    l += i*b-b
                coboundary_basis.append(l)
        return FreeModule_submodule_pid(Module, coboundary_basis)

    def first_cocycle_space(self):
        r"""
        Computes the 1-cocycle space of the group with coefficient in the lattice.

        They are represented as a concatenation of vectors of images of every group element.

        EXAMPLES::

            sage: G = PermutationGroup([(1, 2, 3), (4, 5)])
            sage: GM = GLattice(1)
            sage: L = GM.norm_one_restriction_of_scalars(G)
            sage: CB = L.first_coboundary_space()
            sage: CC = L.first_cocycle_space(); CC
            Free module of degree 30 and rank 5 over Integer Ring
            Echelon basis matrix:
            [ 0  0  0  0  0  1  0  0  1  1  0  0  0  1  1  0 -1  0  0  0  0 -1 -1  0  0  0  0  0  0  1]
            [ 0  0  0  0  0  0  1  0  1  1  0  1  0  0  1  0  0 -1  0  0  1  1  0  1  1  0  1  0  0  0]
            [ 0  0  0  0  0  0  0  1 -1  0  0  0  0 -1 -1  1  1  1  0  1  0  1  1  0  0  1  0  1  0  0]
            [ 0  0  0  0  0  0  0  0  0  0  1  1  0  0  0  1  1  0  0  0  1  1  1  1  0  1  1  1  1  0]
            [ 0  0  0  0  0  0  0  0  0  0  0  0  1  1  0  0  0  1  1  0 -1 -1  0  0  0 -1 -1  0  0  0]
            sage: CC.quotient(CB)
            Finitely generated module V/W over Integer Ring with invariants (6)

        ::

            sage: L2 = GLattice([2, 2]).zero_sum_sublattice()
            sage: CC2 = L2.first_cocycle_space(); CC2
            Free module of degree 12 and rank 2 over Integer Ring
            Echelon basis matrix:
            [ 0  0  0  0  0  1  0  0  0  0  0  1]
            [ 0  0  0  0  0  0  1 -1  0  1 -1  0]
            sage: CB2 = L2.first_coboundary_space()
            sage: CC2.quotient(CB2)
            Finitely generated module V/W over Integer Ring with invariants (2)

        In the second example, the first cohomology is isomorphic to `\ZZ/2 \ZZ`.
        Note that it computes the cocycles and coboundary spaces of an
        isomorphic ambient lattice, not the lattice itself.

        ::

            sage: L3 = GLattice([3], 3)
            sage: L3.first_coboundary_space() == L3.first_cocycle_space()
            True
        """
        lat = self.isomorphic_ambient_lattice()
        r = lat.rank()
        group = lat.group()
        o = group.order()
        rank = r*o
        Module = FreeModule_ambient_pid(ZZ, rank)
        if r == 0:
            return FreeModule_submodule_pid(Module, [])
        grouplist = [g for g in group]
        actionmat = [matrix(lat._action_morphism.Image(g).sage()) for g in grouplist]
        Basis = Module.basis()
        if not grouplist[0] == group.identity():
            grouplist = [group.identity()] + grouplist.remove(group.identity())

        cocycle_space = FreeModule_submodule_pid(Module, [Basis[i] for i in range(r,rank)])

        #Now we apply the cocycle condition for every element of G
        conditions = []
        for g in group.gens():
            ind = grouplist.index(g)
            matbuild = []
            for i in range(o):
                mat = [matrix.zero(r)] * o
                k = grouplist.index(g.inverse() * grouplist[i])
                mat[k] += actionmat[ind]
                mat[ind] += matrix.identity(r)
                matbuild.append(mat)
            conditions.append(block_matrix(matbuild) - 1)
        for c in conditions:
            cocycle_space = cocycle_space.intersection(kernel(c.transpose()))
        return cocycle_space

    def first_cohomology_group(self):
        r"""
        Compute the first cohomology group of a group with coefficient in the lattice.

        OUTPUT:

        - A list of integers corresponding to the isomorphism type as finite abelian group.

        - Generating cocycles of the cohomology group as concatenated vectors of
          images of each group element.

        EXAMPLES::

            sage: L = GLattice([2, 2]).zero_sum_sublattice()
            sage: L.first_cohomology_group()
            ([2], [(0, 0, 0, 0, 0, 0, 1, -1, 0, 1, -1, 0)])

        ::

            sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
            sage: m2 = matrix(3, [-1 ,0 ,0 ,0, -1, 0, 0, 0, -1])
            sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
            sage: L3 = GLattice([m1, m2, m3])
            sage: L3.first_cohomology_group()
            ([2],
             [(0, 0, 0, 1, -1, -1, 1, -1, -1, 0, 0, 0, 1, -1, -1, 0, 0, 0, 0, 0, 0, 1, -1, -1)])
            sage: L3.first_cohomology_group()[0] == L3.tate_cohomology(1) # optional - gap_packages
            True

        TESTS:

            sage: GLattice(0).first_cohomology_group()
            ([], [])
        """
        Coc = self.first_cocycle_space()
        Cob = self.first_coboundary_space()
        M = matrix(ZZ, [Coc.coordinate_vector(i) for i in Cob.basis()])

        a, b, c = M.smith_form()

        P = c.inverse().transpose()
        list_torsion = []
        list_generators = []
        for i in range(a.nrows()):
            if a[i,i] > 1:
                list_torsion.append(a[i,i])
                list_generators.append(sum(P[j, i] * Coc.basis()[j] for j in range(P.ncols())))

        return list_torsion, list_generators

    def Tate_Shafarevich_lattice(self, number = 1, subgp_list=None):
        r"""
        Computes the kernel of the induced map on `H^i` given by restricting to each subgroup in a list.

        INPUT:

        - ``number`` -- The number `i` such that the kernel is a subgroup of `H^i`. Only 1, 2 are supported. When 
          the number is 2, it will be assumed that ``subgp_list`` includes all cyclic subgroups. If it is not the 
          case, one can use the method with `i`= 1 on the lattice obtained with :meth:`dim_shift`.

        - ``subgp_list`` -- list of subgroups, if no argument is given, the list will consist of all cyclic subgroups.

        OUTPUT:

        - the size of the kernel of the induced map on the first cohomology group
          given by restricting to each subgroup.

        - a list of cocycles representing the elements in the kernel.
          Cocycles are represented as concatenated vectors of images of group elements.

        - if ``number`` is 2 and all subgroups in the list are cyclic, then the answer is the first 
          cohomology group of a flabby resolution, so the output is just the isomorphism type as 
          finite abelian group.

        EXAMPLES::

            sage: GM = GLattice(1)
            sage: G = PermutationGroup([(1, 2), (3, 4)])
            sage: L = GM.norm_one_restriction_of_scalars(G)
            sage: SUBGG = G.subgroups()
            sage: CSUB = [g for g in SUBGG if g.is_cyclic()]
            sage: L.Tate_Shafarevich_lattice(1, CSUB)
            [1, [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]]
            sage: L.Tate_Shafarevich_lattice(1, [SUBGG[0]])
            [4,
             [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
              (0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0),
              (0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0),
              (0, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 0)]]
            sage: L.Tate_Shafarevich_lattice(1, [SUBGG[0], SUBGG[1]])
            [2,
             [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 0)]]
            sage: L.Tate_Shafarevich_lattice(2) # optional - gap_packages
            [2]
            sage: L.Tate_Shafarevich_lattice(2, [SUBGG[4]])
            1
        """

        if number == 2:
            if subgp_list == None:
                subgp_list = []
            newsubgp = [h for h in subgp_list if not(h.is_cyclic())]
            [P, F, h] = self.flabby_resolution()
            if newsubgp==[]:
                return F.tate_cohomology(1)
            else:
                return F.Tate_Shafarevich_lattice(1, newsubgp)[0]

        if number == 1:
            isom, gens = self.first_cohomology_group()
            product = cartesian_product_iterator([range(i) for i in isom])
            tate_sha = [sum(c * g for (c, g) in zip(k, gens)) for k in product]
            # We enter the full cohomology group in the Tate cohomology group, we will erase them
            # if they do not vanish on some subgroup.
            #for i in range(len(isom)):
            #    tate_sha += [k*gens[i] for k in range(1,isom[i])]
            if subgp_list==None:
                subgp_list = [h for h in self.group().subgroups() if h.is_cyclic()]

            grouplist = list(self.group())
            for subgp in subgp_list:
                subgp_index = [grouplist.index(h) for h in subgp]

                g_cocycles_basis = [matrix(len(grouplist), b) for b in tate_sha]

                images_as_h_cocyles = [m[subgp_index] for m in g_cocycles_basis]
                listified_images = [[i for j in m for i in j] for m in images_as_h_cocyles]

                cobounds_h = (self.subgroup_lattice(subgp)).first_coboundary_space()
                DummyLat = GLattice(subgp, self.rank() * subgp.order())
                dummybasis = DummyLat.basis()
                notcobounds = []
                for e in range(len(tate_sha)):
                    elt = sum(listified_images[e][i] * dummybasis[i] for i in range(len(listified_images[e])))
                    if elt not in cobounds_h:
                        notcobounds.append(e)
                tate_sha = [tate_sha[i] for i in range(len(tate_sha)) if i not in notcobounds]
            return [len(tate_sha),tate_sha]

    def induced_lattice(self, group, build=True):
        r"""
        Compute an ambient lattice isomorphic to the induction of this lattice
        to a larger group.

        INPUT:

        - ``group`` -- the larger group to induce the lattice to.

        - ``build`` -- boolean (default ``True``).  If ``False``, just returns the matrices
           that define the action on the induced lattice but doesn't build the lattice.

        .. NOTE::

            If a matrix group is entered, it will find an isomorphic permutation group
            to do the induction, so one has to be careful that the isomorphic group
            will contain the permutation group of the lattice. If the lattice is declared
            with matrices, or a matrix group, then inputing a bigger matrix group here
            should work.

        EXAMPLES::

            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix(3, [1, 0, 0, 0, 1, 0, 0, 0, 1])
            sage: L1 = GLattice(G, [act1, act2])
            sage: L1.induced_lattice(SymmetricGroup(5))
            Ambient lattice of rank 60 with a faithful action by a group of order 120

            sage: L2 = GLattice(SymmetricGroup(3), 4)
            sage: L2.induced_lattice(SymmetricGroup(4), False)
            [
            [0 0 0 0|0 0 0 0|0 0 0 0|1 0 0 0]  [1 0 0 0|0 0 0 0|0 0 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 0 0|0 1 0 0]  [0 1 0 0|0 0 0 0|0 0 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 0 0|0 0 1 0]  [0 0 1 0|0 0 0 0|0 0 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 1]  [0 0 0 1|0 0 0 0|0 0 0 0|0 0 0 0]
            [-------+-------+-------+-------]  [-------+-------+-------+-------]
            [1 0 0 0|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|1 0 0 0|0 0 0 0|0 0 0 0]
            [0 1 0 0|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 1 0 0|0 0 0 0|0 0 0 0]
            [0 0 1 0|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 1 0|0 0 0 0|0 0 0 0]
            [0 0 0 1|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 1|0 0 0 0|0 0 0 0]
            [-------+-------+-------+-------]  [-------+-------+-------+-------]
            [0 0 0 0|1 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|1 0 0 0]
            [0 0 0 0|0 1 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|0 1 0 0]
            [0 0 0 0|0 0 1 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|0 0 1 0]
            [0 0 0 0|0 0 0 1|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 1]
            [-------+-------+-------+-------]  [-------+-------+-------+-------]
            [0 0 0 0|0 0 0 0|1 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|1 0 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 1 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 1 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 1 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 1 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 0 1|0 0 0 0], [0 0 0 0|0 0 0 0|0 0 0 1|0 0 0 0]
            ]

        ::

            sage: G = DihedralGroup(4)
            sage: m1 = matrix(2, [0, 1, 1, 0])
            sage: m2 = -matrix.identity(2)
            sage: L = GLattice(G, [m1, m2])
            sage: SL1 = L.zero_sum_sublattice()
            sage: a,b = L.basis()
            sage: SL2 = L.sublattice([a+b])

        ::

            sage: SL1.induced_lattice(SymmetricGroup(4))
            Ambient lattice of rank 3 with a faithful action by a group of order 24
            sage: _._action_matrices
            [
            [-1| 0| 0]  [ 0|-1| 0]
            [--+--+--]  [--+--+--]
            [ 0| 0| 1]  [-1| 0| 0]
            [--+--+--]  [--+--+--]
            [ 0|-1| 0], [ 0| 0| 1]
            ]
            sage: SL2.induced_lattice(SymmetricGroup(4))
            Ambient lattice of rank 3 with a faithful action by a group of order 24
            sage: _._action_matrices
            [
            [ 1| 0| 0]  [ 0|-1| 0]
            [--+--+--]  [--+--+--]
            [ 0| 0|-1]  [-1| 0| 0]
            [--+--+--]  [--+--+--]
            [ 0| 1| 0], [ 0| 0|-1]
            ]

        ::

            sage: G = CyclicPermutationGroup(3)
            sage: mat = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: L = GLattice(G, [mat])
            sage: L.induced_lattice(SymmetricGroup(3))
            Ambient lattice of rank 6 with a faithful action by a group of order 6
            sage: L.induced_lattice(SymmetricGroup(3),False)
            [
            [0 1 0|0 0 0]  [0 0 0|0 0 1]
            [0 0 1|0 0 0]  [0 0 0|1 0 0]
            [1 0 0|0 0 0]  [0 0 0|0 1 0]
            [-----+-----]  [-----+-----]
            [0 0 0|0 0 1]  [0 1 0|0 0 0]
            [0 0 0|1 0 0]  [0 0 1|0 0 0]
            [0 0 0|0 1 0], [1 0 0|0 0 0]
            ]

        ::

            sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
            sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
            sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
            sage: G = MatrixGroup([m1, m2, m3])
            sage: H = MatrixGroup([m1, m2])
            sage: L = GLattice(H)
            sage: L.induced_lattice(G)
            Ambient lattice of rank 6 with a faithful action by a group of order 8
            sage: _._action_matrices
            [
            [ 0  0  0|-1  0  0]  [ 0  0  0| 0  0 -1]  [ 0  0  0| 0  0  1]
            [ 0  0  0| 0 -1  0]  [ 0  0  0| 1  1  1]  [ 0  0  0|-1 -1 -1]
            [ 0  0  0| 0  0 -1]  [ 0  0  0|-1  0  0]  [ 0  0  0| 1  0  0]
            [--------+--------]  [--------+--------]  [--------+--------]
            [-1  0  0| 0  0  0]  [ 0  0 -1| 0  0  0]  [ 0  0  1| 0  0  0]
            [ 0 -1  0| 0  0  0]  [ 1  1  1| 0  0  0]  [-1 -1 -1| 0  0  0]
            [ 0  0 -1| 0  0  0], [-1  0  0| 0  0  0], [ 1  0  0| 0  0  0]
            ]
        """
        if isinstance(group,FinitelyGeneratedMatrixGroup_gap):
            gapgroup = libgap.Group([i.gap() for i in group.gens()])
            iso = gapgroup.IsomorphismPermGroup()
            permg = iso.Image()
            genperm = permg.GeneratorsOfGroup().sage()
            return self.induced_lattice(PermutationGroup(genperm), build)
        elif isinstance(group, SymmetricGroup):
            group = PermutationGroup(group.gens(), canonicalize=False)

        lat = self.isomorphic_ambient_lattice()
        LCos = group.cosets(lat._group, 'left')
        LCosReps = [i[0] for i in LCos]
        LCosnum = len(LCos)

        def get_coset_index(g):
            r"""
            get_coset_index will take an element g of G and return the index of the coset it belongs to
            """
            for i in range(LCosnum):
                if g in LCos[i]:
                    return i
            raise RuntimeError('Found an element which does not belong to any coset')

        def decomp(g):
            r"""
            decomp takes an element `g` of the big group `G`, and returns a pair consisting of the index of the 
            coset `g` belongs to and `h` in the normal group such that `hg_i=g`, where `g_i` is a representative of
            the coset.
            """
            i = get_coset_index(g)
            return i, LCosReps[i].inverse() * g

        def decomp2(g, i):
            r"""
            decomp2(element,index) will do the main computation for the group action on the
            induced lattice (we deal with finite groups so induced is the same as coinduced)
            `\ZZ[G]\otimes_{\ZZ[H]} L `

            To do so, we look at the multiplication g * gi where gi is a representative of the
            ith left coset
            """
            return decomp(g * LCosReps[i])

        # Now we create block matrices corresponding to actions of each generator of G, it
        # is the composition of a block unimodular matrix for permutation of blocks
        # and the block diagonal matrix applying the correct element of H to each block

        def make_matrix(g):
            Lst = [decomp2(g, i) for i in range(LCosnum)]
            Matlist = [matrix(lat._action_morphism.Image(libgap(j[1])).sage())
                       for j in Lst]
            Bigmatlist = []
            for i in range(LCosnum):
                Bigmatlist.extend([Matlist[j] if Lst[j][0] == i else matrix.zero(lat._rank)
                                   for j in range(LCosnum)])
            return block_matrix(LCosnum, LCosnum, Bigmatlist)

        if lat._rank == 0:
            gens_induced_act = [matrix(ZZ, 0) for g in group.gens()]
        else:
            gens_induced_act = [make_matrix(g) for g in group.gens()]
        if build:
            return Lattice_ambient(group, gens_induced_act)
        else:
            return gens_induced_act

    def norm_one_restriction_of_scalars(self, group):
        r"""
        Compute the norm one restriction of scalars as an ambient lattice

        INPUT:

        - ``group`` -- larger group containing the acting group as a subgroup,
            for the restriction of scalars.

        .. NOTE::

            This methods is meant to compute the character lattice of a norm one torus. 
            This only makes sense in a few cases, so this method only works when the initial action 
            is trivial (split torus) or when the group acting is a direct summand of the larger group.

        EXAMPLES::

            sage: G = DihedralGroup(4)
            sage: L = GLattice(G, 3)
            sage: SL = L.zero_sum_sublattice()
            sage: SL.norm_one_restriction_of_scalars(SymmetricGroup(4))
            Ambient lattice of rank 4 with an action by a group of order 24
            sage: _._action_matrices
            [
            [0 0 1 0]  [ 1  0 -1  0]
            [0 0 0 1]  [ 0  1  0 -1]
            [1 0 0 0]  [ 0  0 -1  0]
            [0 1 0 0], [ 0  0  0 -1]
            ]

        If the base group is not a direct summand or the action is not trivial, then the method will not work 
        because the norm map is not well defined::

            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix(3, [1, 0, 0, 0, 1, 0, 0, 0, 1])
            sage: L1 = GLattice(G, [act1, act2])
            sage: L1.norm_one_restriction_of_scalars(SymmetricGroup(5))
            Traceback (most recent call last):
            ...
            ValueError: The basis is not stable under the action of the group

        ::

            sage: L2 = GLattice(SymmetricGroup(3), 4)
            sage: L2.norm_one_restriction_of_scalars(SymmetricGroup(4))
            Ambient lattice of rank 12 with a faithful action by a group of order 24

            sage: L = GLattice(DihedralGroup(4), 4)
            sage: ROS = L.norm_one_restriction_of_scalars(SymmetricGroup(4));ROS
            Ambient lattice of rank 8 with an action by a group of order 24
            sage: ROS._action_matrices
            [
            [0 0 0 0 1 0 0 0]  [ 1  0  0  0 -1  0  0  0]
            [0 0 0 0 0 1 0 0]  [ 0  1  0  0  0 -1  0  0]
            [0 0 0 0 0 0 1 0]  [ 0  0  1  0  0  0 -1  0]
            [0 0 0 0 0 0 0 1]  [ 0  0  0  1  0  0  0 -1]
            [1 0 0 0 0 0 0 0]  [ 0  0  0  0 -1  0  0  0]
            [0 1 0 0 0 0 0 0]  [ 0  0  0  0  0 -1  0  0]
            [0 0 1 0 0 0 0 0]  [ 0  0  0  0  0  0 -1  0]
            [0 0 0 1 0 0 0 0], [ 0  0  0  0  0  0  0 -1]
            ]
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(L.tate_cohomology(i))) # optional - gap_packages
            H^-5:  [2, 2, 2, 2, 2, 2, 2, 2]
            H^-4:  [2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4]
            H^-3:  [2, 2, 2, 2]
            H^-2:  [2, 2, 2, 2, 2, 2, 2, 2]
            H^-1:  []
            H^0:  [8, 8, 8, 8]
            H^1:  []
            H^2:  [2, 2, 2, 2, 2, 2, 2, 2]
            H^3:  [2, 2, 2, 2]
            H^4:  [2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4]
            H^5:  [2, 2, 2, 2, 2, 2, 2, 2]
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(ROS.tate_cohomology(i))) # optional - gap_packages
            H^-5: [6, 6, 6, 6]
            H^-4: [2, 2, 2, 2]
            H^-3: []
            H^-2: [2, 2, 2, 2]
            H^-1: []
            H^0: []
            H^1: []
            H^2: [2, 2, 2, 2]
            H^3: [3, 3, 3, 3]
            H^4: [2, 2, 2, 2]
            H^5: [2, 2, 2, 2]

        ::

            sage: L = GLattice([3])
            sage: G = GLattice([3, 2]).group()
            sage: ROS = L.norm_one_restriction_of_scalars(G); ROS
            Ambient lattice of rank 3 with a faithful action by a group of order 6
            sage: for i in range(-5, 6):  print("H^"+str(i)+": "+str(ROS.tate_cohomology(i)) # optional - gap_packages
            ....: )
            H^-5: [2]
            H^-4: []
            H^-3: [2]
            H^-2: []
            H^-1: [2]
            H^0: []
            H^1: [2]
            H^2: []
            H^3: [2]
            H^4: []
            H^5: [2]
        """
        IL = self.induced_lattice(group)
        n =  group.order()/self.group().order()
        r = self.rank()
        IB = IL.basis()
        B=[sum(IB[i+g*r] for g in range(n)) for i in range(r)]
        return IL.quotient_lattice(IL.sublattice(B))

    def norm(self):
        """
        Return the norm as a lattice morphism.

        EXAMPLES::

            sage: L = GLattice([2, 2])
            sage: L
            Ambient lattice of rank 4 with a faithful action by a group of order 4
            sage: h = L.norm(); h
            Lattice endomorphism defined by the left action of the matrix
            [2 2 0 0]
            [2 2 0 0]
            [0 0 2 2]
            [0 0 2 2]
            Domain: Ambient lattice of rank 4 with a faithful action by a group of order 4
        """
        elts = [sum(self._act(g, b) for g in self.group()) for b in self.basis()]
        M = matrix(elts).transpose()
        return self.left_morphism(M)

    def identity_morphism(self):
        """
        Return the identity map on the matrix.

        EXAMPLES::

            sage: L = GLattice([4])
            sage: h = L.identity_morphism(); h
            Lattice endomorphism defined by the left action of the matrix
            [1 0 0 0]
            [0 1 0 0]
            [0 0 1 0]
            [0 0 0 1]
            Domain: Ambient lattice of rank 4 with a faithful action by a group of order 4
        """
        from sage.matrix.special import identity_matrix
        return self.left_morphism(identity_matrix(self.degree()))

    def coflabby_resolution(self, reduce=True):
        r"""
        Compute a coflabby resolution of a lattice `L` in the form `0\rightarrow K\rightarrow P \rightarrow L\rightarrow 0`.
        The answer consist of a triple of the lattices `K`, `P`, and the surjective map `P\rightarrow L`
        INPUT:

        - ``reduce`` -- boolean (default ``True``), whether the algorithm tries to reduce the dimension of the
           involved lattices.

        OUTPUT:

        - ``K`` -- Coflabby lattice, sublattice of ``P``.
        - ``P`` -- Permutation lattice.
        - ``h`` -- Surjection from ``P`` to ``self``.

        EXAMPLES::

            sage: GM = GLattice([])
            sage: G = SymmetricGroup(3)
            sage: L = GM.induced_lattice(G)
            sage: ZL = L.zero_sum_sublattice()
            sage: ZL.is_coflabby() # optional - gap_packages
            False
            sage: [K, P, h] = ZL.coflabby_resolution(); [K, P, h]
            [Sublattice of degree 12 and rank 7 with a faithful action by a group of order 6 and echelon basis matrix
             [ 1  0  0  0  0  1  0  0  1  0  1  0]
             [ 0  1  0  0  0  1  0 -1  0  0  0 -1]
             [ 0  0  1  0  0  1  0  0  0  0  0  0]
             [ 0  0  0  1  0 -1  0  1  0  0  0  1]
             [ 0  0  0  0  1 -1  0  0 -1  0 -1  0]
             [ 0  0  0  0  0  0  1  1  1  0  0  0]
             [ 0  0  0  0  0  0  0  0  0  1  1  1],
             Ambient lattice of rank 12 with a faithful action by a group of order 6,
             Lattice morphism defined by the left action of the matrix
             [ 1  0  0  0 -1  0| 0  0  0  1 -1  0]
             [ 0 -1  0  1  0  0| 1 -1  0  0  0  0]
             [ 0  0 -1  0  0  1| 0  1 -1  0  0  0]
             [ 0  0  1  0  0 -1| 0  0  0  0  1 -1]
             [ 0  1  0 -1  0  0| 0  0  0 -1  0  1]
             Domain: Ambient lattice of rank 12 with a faithful action by a group of order 6
             Codomain: Ambient lattice of rank 5 with a faithful action by a group of order 6]
            sage: K.is_coflabby() # optional - gap_packages
            True
            sage: h.is_surjective()
            True
        """
        from sage.modules.free_module import span
        lat = self.isomorphic_ambient_lattice()
        orbits = []
        representatives = []
        G = self.group()
        sbgps = G.conjugacy_classes_subgroups()
        for h in sbgps:
            fixed_lat = lat.fixed_sublattice(h)
            if orbits == []:
                testspace = span([tuple([0 for i in range(lat.rank())])], ZZ)
            else:
                testspace = span([sum(lat.orbit(o, h)) for o in orbits], ZZ)
            for e in fixed_lat.basis():
                if not(e in testspace):
                    orb = lat.orbit(e)
                    orbits += orb
                    representatives.append(e)
                    sumorb = [sum(lat.orbit(o, h)) for o in orb]
                    testspace += span(sumorb, ZZ)
        if reduce and len(representatives)>1:
            reducedreps = []
            for r in representatives:
                representativesminusr = [x for x in representatives if x != r]
                check = True
                for h in sbgps:
                    fixlat =  lat.fixed_sublattice(h)
                    bas = [sum(lat.orbit(rr, h)) for rr in representativesminusr]
                    if not(span(bas), ZZ) == fixlat:
                        check = False
                if not(check):
                    reducedreps.append(r)
            representatives = reducedreps
        initial_hom = lat.orbit_permutation_cover(representatives[0])[1]
        homs = [lat.orbit_permutation_cover(r)[1] for r in representatives[1:]]
        hom = initial_hom.exterior_sum(homs, codomain_ext = False)
        return [hom.kernel(), hom.domain(), hom]


    def is_flabby(self):
        r"""
        Checks if a lattice is flabby. A `G`-lattice is flabby if its Tate cohomology group of index `-1` is trivial for
        the restricted action of all subgroups of `G`. 

        EXAMPLES::

            sage: GM = GLattice([])
            sage: G = SymmetricGroup(3)
            sage: L = GM.induced_lattice(G)
            sage: ZL = L.zero_sum_sublattice()
            sage: L.is_flabby()
            True
            sage: ZL.is_flabby()
            False
            sage: ZL.flabby_resolution()[1].is_flabby()
            True
        """
        check = True
        for h in self.group().conjugacy_classes_subgroups(): 
            if self.subgroup_lattice(h).tate_cohomology(-1) != []:
                check = False
        return check

    def is_coflabby(self):
        r"""
        Checks if a lattice is coflabby. A `G`-lattice is flabby if its Tate cohomology group of index `1` is trivial for
        the restricted action of all subgroups of `G`. 

        EXAMPLES::

            sage: GM = GLattice([])
            sage: G = SymmetricGroup(3)
            sage: L = GM.induced_lattice(G)
            sage: ZL = L.zero_sum_sublattice()
            sage: L.is_coflabby() # optional - gap_packages
            True
            sage: ZL.is_coflabby() # optional - gap_packages
            False
            sage: ZL.coflabby_resolution()[0].is_coflabby() # optional - gap_packages
            True
        """
        check = True
        for h in self.group().conjugacy_classes_subgroups(): 
            if self.subgroup_lattice(h).tate_cohomology(1) != []:
                check = False
        return check
    
    def flabby_resolution(self, check = True):
        r"""
        Compute a flabby resolution of a lattice `L` in the form `0\rightarrow L\rightarrow P \rightarrow K\rightarrow 0`.
        The answer consist of a triple of the lattices `P`, `K`, and the injection `L\rightarrow P`
        
        INPUT:

        - ``reduce`` -- boolean (default ``True``), whether the algorithm tries to reduce the dimension of the
           involved lattices.

        OUTPUT:

        - ``P`` -- Permutation lattice.
        - ``K`` -- Flabby lattice, cokernel of ``h``.
        - ``h`` -- Injection from ``self`` to ``P``.

        EXAMPLES::

            sage: GM = GLattice([])
            sage: G = SymmetricGroup(3)
            sage: L = GM.induced_lattice(G)
            sage: ZL = L.zero_sum_sublattice()
            sage: ZL.is_flabby()
            False
            sage: [P, K, h] = ZL.flabby_resolution(); [P, K, h]
            [Ambient lattice of rank 6 with a faithful action by a group of order 6,
             Ambient lattice of rank 1 with the trivial action of a group of order 6,
             Lattice morphism defined by the left action of the matrix
             [ 1  0  0  0  0]
             [--------------]
             [ 0  0  0  0  1]
             [--------------]
             [ 0  0  0  1  0]
             [--------------]
             [ 0  1  0  0  0]
             [--------------]
             [-1 -1 -1 -1 -1]
             [--------------]
             [ 0  0  1  0  0]
             Domain: Ambient lattice of rank 5 with a faithful action by a group of order 6
             Codomain: Ambient lattice of rank 6 with a faithful action by a group of order 6]
            sage: K.is_flabby()
            True
            sage: h.is_injective()
            True
        """
        [K, P, hom] = self.colattice().coflabby_resolution(check)
        return [P.colattice(), K.colattice(), hom.dual()]

    def zero_sum_sublattice(self, ambient=False):
        r"""
        Return the sublattice of elements with coordinates summing up to zero.

        INPUT:

        - ``ambient`` -- boolean (default ``False``), whether to return
            an ambient lattice isomorphic to the zero sum sublattice, as opposed
            to the sublattice of zero sum vectors.

        .. NOTE::

            The zero sum sublattice is not necessarily stable under the group
            action, as the last example will illustrate.

        EXAMPLES::

            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix(3, [1, 0, 0, 0, 1, 0, 0, 0, 1])
            sage: L1 = GLattice(G, [act1, act2])
            sage: L2 = GLattice(SymmetricGroup(3), 4)

        ::

            sage: L1.zero_sum_sublattice()
            Sublattice of degree 3 and rank 2 with an action by a group of order 6 and echelon basis matrix
            [ 1  0 -1]
            [ 0  1 -1]
            sage: L2.zero_sum_sublattice()
            Sublattice of degree 4 and rank 3 with the trivial action of a group of order 6 and echelon basis matrix
            [ 1  0  0 -1]
            [ 0  1  0 -1]
            [ 0  0  1 -1]

        We can make them directly ambient lattices::

            sage: L1.zero_sum_sublattice(True)
            Ambient lattice of rank 2 with an action by a group of order 6
            sage: _._action_matrices
            [
            [ 0  1]  [1 0]
            [-1 -1], [0 1]
            ]
            sage: L2.zero_sum_sublattice(True)
            Ambient lattice of rank 3 with the trivial action of a group of order 6
            sage: _._action_matrices
            [
            [1 0 0]  [1 0 0]
            [0 1 0]  [0 1 0]
            [0 0 1], [0 0 1]
            ]

        Now we decide not to transform it into an ambient lattice, but to create the sublattice of
        zero sum vectors.::

            sage: L = GLattice(SymmetricGroup(3), 5)
            sage: L.zero_sum_sublattice()
            Sublattice of degree 5 and rank 4 with the trivial action of a group of order 6 and echelon basis matrix
            [ 1  0  0  0 -1]
            [ 0  1  0  0 -1]
            [ 0  0  1  0 -1]
            [ 0  0  0  1 -1]
            sage: L.zero_sum_sublattice().zero_sum_sublattice()
            Sublattice of degree 5 and rank 4 with the trivial action of a group of order 6 and echelon basis matrix
            [ 1  0  0  0 -1]
            [ 0  1  0  0 -1]
            [ 0  0  1  0 -1]
            [ 0  0  0  1 -1]
            sage: L.zero_sum_sublattice(True).zero_sum_sublattice(True)
            Ambient lattice of rank 3 with the trivial action of a group of order 6


        Here we see that the zero sum sublattice of the zero sum sublattice is itself,
        which is not the case when we return an ambient ambient lattice.::

            sage: L = GLattice(SymmetricGroup(3), 5)
            sage: SL = L.sublattice([L.basis()[2]+3*L.basis()[4], 5*L.basis()[0]+L.basis()[1], L.basis()[1]+6*L.basis()[3]]); SL
            Sublattice of degree 5 and rank 3 with the trivial action of a group of order 6 and echelon basis matrix
            [ 5  0  0 -6  0]
            [ 0  1  0  6  0]
            [ 0  0  1  0  3]
            sage: SL.zero_sum_sublattice()
            Sublattice of degree 5 and rank 2 with the trivial action of a group of order 6 and echelon basis matrix
            [  5   3  -5  12 -15]
            [  0   4  -7  24 -21]

        ::

            sage: L = GLattice(DihedralGroup(4), 4)
            sage: L.zero_sum_sublattice()
            Sublattice of degree 4 and rank 3 with the trivial action of a group of order 8 and echelon basis matrix
            [ 1  0  0 -1]
            [ 0  1  0 -1]
            [ 0  0  1 -1]

        ::

            sage: L.zero_sum_sublattice(True)
            Ambient lattice of rank 3 with the trivial action of a group of order 8


        Here is an example of lattice whose zero sum submodule over `\ZZ`
        is not stable under the group action::

            sage: G = SymmetricGroup(2)
            sage: m = matrix(2, [-1, 0, 0, 1])
            sage: L = GLattice(G, [m])
            sage: L.zero_sum_sublattice()
            Traceback (most recent call last):
            ...
            ValueError: The basis is not stable under the action of the group

        """
        if ambient:
            # This does the following, for each nxn matrix defining the action of the induced representation,
            # it extracts two blocks
            # (        |   )
            # (    A   | B )     A which is of size n-1 x n-1
            # (        |   ) and B which is of size n-1 x 1
            # (------------)
            # (    C   | D )

            # Then it computes the action for the norm 1 restriction of scalars, which is
            # A - B * (1,1,...,1)

            # Indeed, since the norm 1 restriction lattice will be the sublattice
            # of elements summing up to 0, so we only consider the first n-1 basis elements,
            # doing the matrix computation, the element l = (l_1,...l_(n-1)) is sent to
            # A *l + B * (-sum_i l_i), which is the transformation A-B*(1,...,1)
            acts = self._action_matrices
            newacts = [A[list(range(A.ncols() - 1)), list(range(A.ncols()-1))] - A[list(range(A.ncols() - 1)), [A.ncols() - 1]] * matrix(1, [1 for i in range(A.ncols() - 1)]) for A in acts]
            return Lattice_ambient(self._group, newacts)
        else:
            oldBasis = self.basis()
            newBasis = [v - oldBasis[-1] for v in oldBasis[:-1]]
            return self.sublattice(newBasis)

    def dim_shift(self, direction="Left", build=True):
        r"""
        Return a lattice whose `i`-th Tate cohomology group is the
        `i+1`-th Tate cohomology group of the original lattice if ``direction`` is ``Left``,
        or `i-1`-th Tate cohomology group if ``direction`` is ``Right``.

        INPUT:

        - ``direction`` -- Choice (default ``Left``) whether one will perform dimension shift on the left or
          on the right.

        - ``build`` -- boolean (default ``True``).  If ``False``, returns a pair of lattices whose quotient
          is the Left-dimension-shifted lattice.  If ``True``, returns the dimension-shifted
          lattice itself. For shifts on the right, it will always build the lattice.

        EXAMPLES::

            sage: L = GLattice(1)
            sage: G = SymmetricGroup(2)
            sage: GM = GLattice(1)
            sage: G = PermutationGroup([(1, 2), (3, 4)])
            sage: IL = GM.induced_lattice(G)
            sage: m = IL._action_matrices[0]
            sage: B = m.eigenspaces_right()[0][1].basis()
            sage: SL1 = IL.sublattice(B)
            sage: SL2 = SL1.zero_sum_sublattice()
            sage: QL = IL.quotient_lattice(SL2); QL
            Ambient lattice of rank 3 with a faithful action by a group of order 4
            sage: QL.tate_cohomology(1) # optional - gap_packages
            [2]
            sage: QL.tate_cohomology(2) # optional - gap_packages
            [2, 2]
            sage: DQL = QL.dim_shift()
            sage: DQL.tate_cohomology(1) # optional - gap_packages
            [2, 2]

        The cohomology of the quaternion group is `4`-periodic, so we can see both shifts clearly.

        ::

            sage: Q = QuaternionGroup()
            sage: L = GLattice(1).norm_one_restriction_of_scalars(Q)
            sage: lL = L.dim_shift()
            sage: rL = L.dim_shift("Right")
            sage: [L.tate_cohomology(i) for i in range(4)] # optional - gap_packages
            [[], [2, 2], [], [8]]
            sage: [lL.tate_cohomology(i) for i in range(4)] # optional - gap_packages
            [[2, 2], [], [8], []]
            sage: [rL.tate_cohomology(i) for i in range(4)] # optional - gap_packages
            [[8], [], [2, 2], []]
        """

        if direction == "Left":
            lat = self.isomorphic_ambient_lattice()
            GG = lat.group()
            H = PermutationGroup([()])
            G = [c[0] for c in GG.cosets(H,'left')]
            TL = lat.subgroup_lattice(H).induced_lattice(GG)
            Newbasis = []
            Basiselt = 0
            r = lat.rank()
            Indbasis = TL.basis()
            for b in lat.basis():
                for i in range(len(G)):
                    elt = lat._act(G[i].inverse(), b)
                    Basiselt += sum(elt[j] * Indbasis[j + i*r] for j in range(len(elt)))
                Newbasis.append(Basiselt)
                Basiselt = 0
            ImageL = SubLattice(TL, Newbasis)
            if build:
                return TL.quotient_lattice(ImageL)
            else:
                return [TL, ImageL]
        elif direction == "Right":
            return self.dual().dim_shift(direction="Left", build=True).dual()
        else:
            raise ValueError("direction must be either `Left` or `Right`")


    def _Hom_(self, Y, category):
        from .glattice_homspace import GLatticeHomspace
        return GLatticeHomspace(self, Y, category)

    def hom(self, im_gens, codomain=None, **kwds):
        """
        Override the hom method to handle the case of morphisms given by left-multiplication
        of a matrix and the codomain is not given.
        """
        from sage.structure.element import is_Matrix
        if codomain is None and is_Matrix(im_gens):
            codomain = self
        return super().hom(im_gens, codomain, **kwds)


    def sublattice(self, basis, check=True):
        r"""
        Constructs the sublattice spanned by a list of vectors.

        INPUT:

        - ``basis`` -- desired basis for the sublattice

        - ``check`` -- boolean (default ``True``), ``False`` if we do not want to check that
            the lattice is stable under the action of the group.

        EXAMPLES::

            sage: L = GLattice(SymmetricGroup(3))
            sage: SL = L.sublattice([sum(i for i in L.basis())]); SL
            Sublattice of degree 3 and rank 1 with a faithful action by a group of order 6 and echelon basis matrix
            [1 1 1]
        """
        return SubLattice(self, basis, check)

    def quotient_lattice(self, sublattice, check=True, morphism = False):
        r"""
        Return an ambient lattice isomorphic to the quotient of two lattices.

        INPUT:

        - ``sublattice`` -- sublattice by which we want to quotient

        - ``check`` -- boolean (default ``True``), ``True`` if one wants to check that the
            sublattice is saturated and proper

        - ``morphism`` -- boolean (default ``False``), ``True`` if one wants the method to return
            the quotient morphism.

        EXAMPLES::

            sage: m = matrix([[0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0]])
            sage: L = GLattice([2], [m]); L._action_matrices
            [
            [0 0 0 0 0 1]
            [0 0 0 0 1 0]
            [0 0 0 1 0 0]
            [0 0 1 0 0 0]
            [0 1 0 0 0 0]
            [1 0 0 0 0 0]
            ]
            sage: B = L.basis()
            sage: SL = L.sublattice([B[1], B[2], B[3], B[4]])
            sage: SSL = SL.sublattice([B[2], B[3]])
            sage: SSSL1 = SSL.sublattice([B[2] + B[3]])
            sage: SSSL2 = SSL.sublattice([B[2] - B[3]])

        ::

            sage: Q1 = L.quotient_lattice(SL); Q1; Q1._action_matrices
            Ambient lattice of rank 2 with a faithful action by a group of order 2
            [
            [0 1]
            [1 0]
            ]
            sage: Q2 = L.quotient_lattice(SSSL1); Q2; Q2._action_matrices
            Ambient lattice of rank 5 with a faithful action by a group of order 2
            [
            [ 0  0  0  0  1]
            [ 0  0  0  1  0]
            [ 0  0 -1  0  0]
            [ 0  1  0  0  0]
            [ 1  0  0  0  0]
            ]
            sage: Q3 = SL.quotient_lattice(SSL); Q3; Q3._action_matrices
            Ambient lattice of rank 2 with a faithful action by a group of order 2
            [
            [0 1]
            [1 0]
            ]
            sage: Q4 = SL.quotient_lattice(SSSL1); Q4; Q4._action_matrices
            Ambient lattice of rank 3 with a faithful action by a group of order 2
            [
            [ 0  0  1]
            [ 0 -1  0]
            [ 1  0  0]
            ]
            sage: Q5 = SL.quotient_lattice(SSSL2); Q5; Q5._action_matrices
            Ambient lattice of rank 3 with a faithful action by a group of order 2
            [
            [0 0 1]
            [0 1 0]
            [1 0 0]
            ]
            sage: Q6 = SSL.quotient_lattice(SSSL1); Q6; Q6._action_matrices
            Ambient lattice of rank 1 with a faithful action by a group of order 2
            [[-1]]
            sage: Q7 = SSL.quotient_lattice(SSSL2); Q7; Q7._action_matrices
            Ambient lattice of rank 1 with the trivial action of a group of order 2
            [[1]]

        ::

            sage: G = SymmetricGroup(3)
            sage: L = GLattice(2)
            sage: LL = GLattice(G, 5)
            sage: IL = L.induced_lattice(G)
            sage: ZL = IL.zero_sum_sublattice()
            sage: SL = LL.sublattice([LL.basis()[0], LL.basis()[1] + LL.basis()[2], LL.basis()[4]])

        ::

            sage: QL1 = LL.quotient_lattice(SL); QL1
            Ambient lattice of rank 2 with the trivial action of a group of order 6
            sage: QL1._action_matrices
            [
            [1 0]  [1 0]
            [0 1], [0 1]
            ]

        ::

            sage: QL2 = IL.quotient_lattice(ZL); QL2
            Ambient lattice of rank 1 with the trivial action of a group of order 6
            sage: QL2._action_matrices
            [[1], [1]]

        One can also return the quotient map.

        ::

            sage: L = GLattice([2, 2])
            sage: [a, b, c, d] = L.basis()
            sage: SL = L.sublattice([a+b+c+d])
            sage: L.quotient_lattice(SL)
            Ambient lattice of rank 3 with a faithful action by a group of order 4
            sage: L.quotient_lattice(SL, True, True)
            [Ambient lattice of rank 3 with a faithful action by a group of order 4,
             Lattice morphism defined by the left action of the matrix
             [-1  0  0  1]
             [-1  0  1  0]
             [-1  1  0  0]
             Domain: Ambient lattice of rank 4 with a faithful action by a group of order 4
             Codomain: Ambient lattice of rank 3 with a faithful action by a group of order 4]
            sage: L.quotient_lattice(L.zero_sum_sublattice())
            Ambient lattice of rank 1 with the trivial action of a group of order 4
            sage: [Q, h] = L.quotient_lattice(L.zero_sum_sublattice(), True, True); [Q, h]
            [Ambient lattice of rank 1 with the trivial action of a group of order 4,
             Lattice morphism defined by the left action of the matrix
             [1 1 1 1]
             Domain: Ambient lattice of rank 4 with a faithful action by a group of order 4
             Codomain: Ambient lattice of rank 1 with the trivial action of a group of order 4]
            sage: k = L.norm().kernel().injection_morphism()
            sage: h.pre_compose(k)
            Lattice morphism defined by the left action of the matrix
            [0 0]
            Domain: Ambient lattice of rank 2 with a faithful action by a group of order 4
            Codomain: Ambient lattice of rank 1 with the trivial action of a group of order 4



        TESTS::

            sage: Q8 = GLattice(2)
            sage: Z8 = Q8.sublattice([])
            sage: Q8.quotient_lattice(Z8)
            Ambient lattice of rank 2 with an action by a group of order 1
        """
        if sublattice.rank() == 0:
            return self.isomorphic_ambient_lattice()

        if sublattice.injection_morphism().is_surjective():
            return GLattice(self.group(), 0)

        if self.is_ambient():
            act_builder = self._action_matrices
            M = matrix(sublattice.basis())
        else:
            oldBasis = self.basis()
            act_builder = []
            for g in self._group.gens():
                mat_builder = []
                for i in oldBasis:
                    mat_builder.append(self.coordinate_vector(self._act(g,i)))
                act_builder.append(matrix(mat_builder).transpose())
            M = matrix([self.coordinate_vector(i) for i in sublattice.basis()])

        SM = M.smith_form()

        if check and ((not SM[0][sublattice.rank()-1,sublattice.rank()-1] == 1) or sublattice.rank() == self.rank()):
            raise ValueError("The sublattice is not saturated or not proper"    )

        P = SM[2].transpose()

        Pi = P.inverse()

        index = range(sublattice.rank(), self.rank())
        v = Pi[range(self.rank()), index]

        A = [(P*i*v)[list(index)] for i in act_builder]
        if not self.is_ambient():
            n = A[0].nrows()
            ide = matrix.identity(n)
            J = matrix([ide[n-1-k] for k in range(n)])
            # This computes the action on the vectors of the complement of the sublattice
            A = [J*(a.transpose())*J for a in A]
        qlat = Lattice_ambient(self.group(), A)
        if morphism:
            v2 = P[range(sublattice.rank(), self.rank()), range(self.rank())]
            mor = self.left_morphism(v2, qlat)
            return [qlat, mor]
        else:
            return Lattice_ambient(self.group(), A)


class Lattice_ambient(FreeModule_ambient_pid, Lattice_generic):
    r"""
    Class for ambient lattices.

    INPUT:

    - ``galois`` -- the group acting on the lattice, either permutation
        group or finite sugroup of `GL_n(\ZZ)` for some n. It can be a list
        of integers for a finite abelian group of that type.

    - ``action`` -- the list of matrices by which the generators of the group
        act, or an integer for the trivial action on the ambient free
        `\ZZ` module of that rank.

    - ``check`` -- boolean (default ``True``). If ``True``, checks that the action
        of the group is a well-defined group action.

    EXAMPLES::

        sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
        sage: act2 = matrix.identity(3)
        sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
        sage: GLattice(G, [act1, act2])
        Ambient lattice of rank 3 with an action by a group of order 6

    ::

        sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
        sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
        sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
        sage: GLattice([m1, m2, m3])
        Ambient lattice of rank 3 with a faithful action by a group of order 8
    """
    def __init__(self, galois, action, check=True):
        r"""
        Constructs an ambient lattice.

        TESTS::

            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix.identity(3)
            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: X = GLattice(G, [act1, act2])
            sage: TestSuite(X).run()
        """
        Lattice_generic.__init__(self, galois, action, check)
        FreeModule_ambient_pid.__init__(self, ZZ, self._rank)

    def __reduce__(self):
        r"""
        Pickling.

        TESTS::

            sage: L = GLattice(SymmetricGroup(3), 5)
            sage: L == loads(dumps(L))
            True
        """
        return self.__class__, (self._group, self._action_matrices, False)

    def _repr_(self):
        r"""
        The print representation of an ambient lattice.

        EXAMPLES::

            sage: GLattice(1)
            Ambient lattice of rank 1 with an action by a group of order 1
            sage: GLattice(SymmetricGroup(3))
            Ambient lattice of rank 3 with a faithful action by a group of order 6
        """
        r = self.rank()
        n = self.group().order()
        arep = self._action_repr()
        return "Ambient lattice of rank %s with %s a group of order %s" % (r, arep, n)

class SubLattice(Lattice_generic, FreeModule_submodule_pid):
    r"""
    Class for sublattices of other lattices (either ambient ones, or sublattices themselves).

        INPUT:

        - ``lattice`` -- the lattice (ambient or not) in which our lattice embeds

        - ``basis`` -- basis generating the sublattice.

        - ``check`` -- boolean (default ``True``). If ``True``, checks that
            the sublattice is stable under the action of the group.

        EXAMPLES::

            sage: L = GLattice([10]); L
            Ambient lattice of rank 10 with a faithful action by a group of order 10
            sage: b = sum(L.basis())
            sage: L.sublattice([b])
            Sublattice of degree 10 and rank 1 with a faithful action by a group of order 10 and echelon basis matrix
            [1 1 1 1 1 1 1 1 1 1]
    """
    def __init__(self, lattice, basis, check=True):
        r"""
        Initialization of sublattice.

        TESTS::

            sage: L = GLattice([10])
            sage: b = sum(L.basis())
            sage: TestSuite(L.sublattice([b])).run()
        """
        Lattice_generic.__init__(self, lattice.group(), lattice._action_matrices, check)
        FreeModule_submodule_pid.__init__(self, lattice.ambient_lattice(), basis)

        Submod = FreeModule_submodule_pid(lattice.ambient_lattice(), basis)
        self._ambient_lattice = lattice.ambient_lattice()
        if check:
            for i in lattice.group().gens():
                for j in basis:
                    if not lattice._act(i,j) in Submod:
                        raise ValueError("The basis is not stable under the action of the group")

    def __reduce__(self):
        r"""
        Pickling.

        TESTS::

            sage: L = GLattice([10])
            sage: b = sum(L.basis())
            sage: M = L.sublattice([b])
            sage: M == loads(dumps(M))
            True
        """
        return self.__class__, (self._ambient_lattice, [tuple(v) for v in self.basis()], False)

    def _repr_(self):
        r"""
        The print representation of a sublattice.

        EXAMPLES::

            sage: L = GLattice(3)
            sage: SL = L.sublattice([sum(i for i in L.basis())]); SL
            Sublattice of degree 3 and rank 1 with an action by a group of order 1 and echelon basis matrix
            [1 1 1]
            sage: SL2 = L.zero_sum_sublattice(); SL2
            Sublattice of degree 3 and rank 2 with an action by a group of order 1 and echelon basis matrix
            [ 1  0 -1]
            [ 0  1 -1]
        """
        d = self.degree()
        r = self.rank()
        n = self.group().order()
        arep = self._action_repr()
        E = self.echelonized_basis_matrix()
        return "Sublattice of degree %s and rank %s with %s a group of order %s and echelon basis matrix\n%s" % (d, r, arep, n, E)

    def __add__(self, other):
        r"""
        Return the sum as submodules of this lattice and another.

        EXAMPLES::

            sage: L = GLattice([2, 3])
            sage: ROS = L.zero_sum_sublattice()
            sage: FL = L.fixed_sublattice()
            sage: ROS + FL
            Sublattice of degree 5 and rank 5 with a faithful action by a group of order 6 and echelon basis matrix
            [1 0 0 0 0]
            [0 1 0 0 0]
            [0 0 1 0 0]
            [0 0 0 1 0]
            [0 0 0 0 1]
        """
        s = FreeModule_submodule_pid.__add__(self, other)
        return self.ambient_lattice().sublattice(s.basis(), check=False)

    def _mul_(self, other, switch_sides=False):
        r"""
        Multiplication of the basis by ``other``.

        EXAMPLES::

            sage: L = GLattice([2,3])
            sage: FL = L.fixed_sublattice()
            sage: FL
            Sublattice of degree 5 and rank 2 with a faithful action by a group of order 6 and echelon basis matrix
            [1 1 0 0 0]
            [0 0 1 1 1]
            sage: 2*FL
            Sublattice of degree 5 and rank 2 with a faithful action by a group of order 6 and echelon basis matrix
            [2 2 0 0 0]
            [0 0 2 2 2]
            sage: FL*2
            Sublattice of degree 5 and rank 2 with a faithful action by a group of order 6 and echelon basis matrix
            [2 2 0 0 0]
            [0 0 2 2 2]
        """
        B = FreeModule_submodule_pid._mul_(self, other, switch_sides).basis()
        return self.ambient_lattice().sublattice(B, check=False)


    


    def ambient_lattice(self):
        r"""
        Return the ambient lattice containing this sublattice.

        EXAMPLES::

            sage: L = GLattice(DihedralGroup(4), 4).zero_sum_sublattice()
            sage: L.ambient_lattice()
            Ambient lattice of rank 4 with the trivial action of a group of order 8

            sage: L = GLattice([2, 3])
            sage: ZL = L.zero_sum_sublattice()
            sage: ZL.ambient_lattice()
            Ambient lattice of rank 5 with a faithful action by a group of order 6
            sage: ZL.ambient_lattice() is L
            True
        """
        return self._ambient_lattice
    def injection_morphism(self, side="left"):
        """
        Return the injection between two ambient lattices such that ``self`` is the image.

        EXAMPLES::

            sage: L = GLattice([2, 2])
            sage: ZL = L.zero_sum_sublattice()
            sage: h = ZL.injection_morphism(); h
            Lattice morphism defined by the left action of the matrix
            [ 1  0  0]
            [ 0  1  0]
            [ 0  0  1]
            [-1 -1 -1]
            Domain: Ambient lattice of rank 3 with a faithful action by a group of order 4
            Codomain: Ambient lattice of rank 4 with a faithful action by a group of order 4
            sage: h.is_injective()
            True
            sage: SL = L.sublattice([sum(L.basis())])
            sage: SL.injection_morphism()
            Lattice morphism defined by the left action of the matrix
            [1]
            [1]
            [1]
            [1]
            Domain: Ambient lattice of rank 1 with the trivial action of a group of order 4
            Codomain: Ambient lattice of rank 4 with a faithful action by a group of order 4
        """

        amb = self.isomorphic_ambient_lattice()
        if side == "right":
            inj = amb.hom(matrix(self.basis()), self.ambient_lattice()) 
        else:
            inj = amb.left_morphism(matrix(self.basis()).transpose(), self.ambient_lattice()) 
        return inj

    def isomorphic_ambient_lattice(self):
        r"""
        Gives an isomorphic ambient lattice.

        EXAMPLES::

            sage: L = GLattice(DihedralGroup(4), 4)
            sage: SL1 = L.zero_sum_sublattice()
            sage: SL1 = L.zero_sum_sublattice(); SL1
            Sublattice of degree 4 and rank 3 with the trivial action of a group of order 8 and echelon basis matrix
            [ 1  0  0 -1]
            [ 0  1  0 -1]
            [ 0  0  1 -1]
            sage: SL1.isomorphic_ambient_lattice()
            Ambient lattice of rank 3 with the trivial action of a group of order 8
        """
        oldBasis = self.basis()
        act_builder = []
        for g in self.group().gens():
            mat_builder = []
            for i in oldBasis:
                mat_builder.append(self.coordinate_vector(self._act(g,i)))
            act_builder.append(matrix(mat_builder).transpose())
        return Lattice_ambient(self.group(),act_builder)

    def zero_sum_sublattice(self, ambient=False):
        r"""
        Create the sublattice of the vectors with zero sum of coordinates
        in the ambient module.

        INPUT:

        - ``ambient`` -- boolean (default ``False``), whether to return an ambient lattice
          isomorphic to the zero sum sublattice.

        .. NOTE::

            Not all zero sum lattices are stable under the action of the group;
            this method can fail in such a case.

        EXAMPLES::

            sage: G = SymmetricGroup(3)
            sage: L1 = GLattice(G, 5)
            sage: a,b,c,d,e = L1.basis()
            sage: SL1 = L1.sublattice([a+2*b+d, d-5*e, 3*c]); SL1
            Sublattice of degree 5 and rank 3 with the trivial action of a group of order 6 and echelon basis matrix
            [ 1  2  0  0  5]
            [ 0  0  3  0  0]
            [ 0  0  0  1 -5]
            sage: SL1.zero_sum_sublattice()
            Sublattice of degree 5 and rank 2 with the trivial action of a group of order 6 and echelon basis matrix
            [  1   2   0   2  -5]
            [  0   0  12   3 -15]
            sage: SL1.zero_sum_sublattice(True)
            Ambient lattice of rank 2 with the trivial action of a group of order 6

        Next is another example of sublattice where the zero sum submodule
        is not stable under the group action::

            sage: G2 = CyclicPermutationGroup(2)
            sage: m = matrix([[0, 1, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, -1, 0], [0, 0, 0, 0, -1]])
            sage: L2 = GLattice(G2, [m])
            sage: a,b,c,d,e = L2.basis()
            sage: SL2 = L2.sublattice([a, b, d]); SL2
            Sublattice of degree 5 and rank 3 with a faithful action by a group of order 2 and echelon basis matrix
            [1 0 0 0 0]
            [0 1 0 0 0]
            [0 0 0 1 0]
            sage: SL2.zero_sum_sublattice()
            Traceback (most recent call last):
            ...
            ValueError: The basis is not stable under the action of the group
        """
        oldBasis = self.basis()
        newBasis = []
        diagonal = 0
        for i in self._ambient_lattice.basis():
            diagonal += i
        totals = [i.inner_product(diagonal) for i in oldBasis]
        gcd, coefs = extended_xgcd(totals)
        if gcd == 0:
            return self
        dist_elt = 0
        for i in range(len(oldBasis)):
            dist_elt += coefs[i]*oldBasis[i]
        for i in range(len(oldBasis)):
            newBasis.append(oldBasis[i] - Integer((totals[i] / gcd)) * dist_elt)
        while 0 in newBasis:
            newBasis.remove(0)
        result = SubLattice(self._ambient_lattice, newBasis)
        return result if not ambient else result.isomorphic_ambient_lattice()


